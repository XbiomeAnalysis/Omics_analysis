[["index.html", "Omics analysis Chapter 1 OMics Analysis Template 1.1 WGCNA Preface 1.2 WGCNA Introduction 1.3 HAllA Introduction", " Omics analysis Zhengnong Zhu and Yifan Zhao 2022-07-08 Chapter 1 OMics Analysis Template 1.1 WGCNA Preface In this book, we will introduce an method of multi-omics association analysis, entitled WGCNA. We will introduce usage and principle of WGCNA. Moreover, we will utilize GVHD data to illustate pipelines of WGCNA. 1.2 WGCNA Introduction Correlation networks are increasingly being used in bioinformatics applications. For example, weighted gene co-expression network analysis is a systems biology method for describing the correlation patterns among genes across microarray samples. Weighted correlation network analysis (WGCNA) can be used for finding clusters (modules) of highly correlated genes, for summarizing such clusters using the module eigengene or an intramodular hub gene, for relating modules to one another and to external sample traits (using eigengene network methodology), and for calculating module membership measures. Correlation networks facilitate network based gene screening methods that can be used to identify candidate biomarkers or therapeutic targets. These methods have been successfully applied in various biological contexts, e.g. cancer, mouse genetics, yeast genetics, and analysis of brain imaging data. While parts of the correlation network methodology have been described in separate publications, there is a need to provide a user-friendly, comprehensive, and consistent software implementation and an accompanying tutorial. The WGCNA R software package is a comprehensive collection of R functions for performing various aspects of weighted correlation network analysis. The package includes functions for network construction, module detection, gene selection, calculations of topological properties, data simulation, visualization, and interfacing with external software. Along with the R package we also present R software tutorials. While the methods development was motivated by gene expression data, the underlying data mining approach can be applied to a variety of different settings. WGCNA source 1.3 HAllA Introduction HAllA (Hierarchical All-against-All association) 是一个针对多维度、异质型数据集的多重关联分析工具。可用于连续型/分类型数值数据，且在同质型（homogeneous）数据集（所有数值皆相同类型，例如：RNA-seq 基因表現）与异质型（heterogeneous）数据集（不同单位或类型的数值，例如：病患临床指标）皆可高效分析。在目前微生物研究中，HAllA是一個常用于微生物组-代谢、微生物组-临床指标、微生物组-转录组（基因表現、miRNA、GO） 等关联分析的重要工具。 HAllA source "],["wgcna-template.html", "Chapter 2 WGCNA template 2.1 load package 2.2 load data 2.3 restructured the hierarchy table 2.4 mgs standardization 2.5 mgs constructe module 2.6 metabolites constructe module 2.7 metabolites, mgs and metadata association 2.8 Visualization network 2.9 Session Info", " Chapter 2 WGCNA template 2.1 load package knitr::opts_chunk$set(echo = TRUE) library(tidyverse) library(xlsx) library(WGCNA) library(igraph) library(phyloseq) library(DT) options(stringsAsFactors = FALSE) 2.2 load data metagenomics metabolic metadata mgs_profile &lt;- read.table(&quot;/home/xuxiaomin/project/NanFangHospitalGvHD/02.MGS_output/metaphlan2_merged.tsv&quot;, header = TRUE, sep = &quot;\\t&quot;) # read metagenomic hirerachy table，only need ID column metabolites_level &lt;- read.xlsx(&quot;/home/zhaoyifan/zhaoyifan_Xbiome1/project/GVHD/metabolites_TM/ALL_sample_data.xlsx&quot;, sheetIndex = 1) # read metabolic hirerachy table mgs &lt;- read.table(&quot;/home/zhaoyifan/projects/Analytics/analytics/MultiOmics/tools/HAllA/GvHD/metagenomics.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) # read metagenomic species level data metabolites_data &lt;- read.table(&quot;/home/zhaoyifan/projects/Analytics/analytics/MultiOmics/tools/HAllA/GvHD/metabolic.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) # read metabolic data metadata &lt;- read.table(&quot;/home/zhaoyifan/projects/Analytics/analytics/MultiOmics/tools/HAllA/GvHD/metadata.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) # read metadata mgs_profile need taxanomy level column, as shwon in the table below datatable(mgs_profile[1:10, 1:10]) Metabolic level data are selected as the Class.I and Class.II column in the following analysis, the details can be adjusted according to the data reality datatable(metabolites_level[1:10, 1:10]) mgs species: row names are Features, column names are Sample metabolites_data: row names are Features, column names are Sample 2.3 restructured the hierarchy table # taxa hierarchy table mgs_species &lt;- mgs_profile %&gt;% .[sapply(str_split(mgs_profile$ID, &quot;\\\\|&quot;), function(x) length(x) == 7), ] taxa_table &lt;- str_split_fixed(mgs_species$ID,&quot;\\\\|&quot;, 7) %&gt;% as.data.frame() colnames(taxa_table) &lt;- c(&quot;Kingdom&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;, &quot;Species&quot;) rownames(taxa_table) &lt;- str_replace(taxa_table$Species, &quot;s__&quot;, &quot;&quot;) # metabolic hierarchy table metabolites_level &lt;- metabolites_level %&gt;% select(Index, Class.I, Class.II) metabolites_level &lt;- metabolites_level %&gt;% column_to_rownames(&quot;Index&quot;) 2.4 mgs standardization 2.4.1 check data format cat(&quot;[mgs]&quot;, paste(c(&quot;Feature: &quot;, &quot;Sample: &quot;), dim(mgs))) ## [mgs] Feature: 250 Sample: 32 cat(&quot;[metabolites]&quot;, paste0(c(&quot;Feature: &quot;, &quot;Sample: &quot;), dim(metabolites_data))) ## [metabolites] Feature: 811 Sample: 32 2.4.2 using CSS method data.metagenomeSeq &lt;- metagenomeSeq::newMRexperiment(mgs) # Variables as rows, samples as columns p &lt;- metagenomeSeq::cumNormStat(data.metagenomeSeq) ## Default value being used. data.cumnorm &lt;- metagenomeSeq::cumNorm(data.metagenomeSeq, p=p) mgs &lt;- metagenomeSeq::MRcounts(data.cumnorm, norm=TRUE, log=TRUE) # log here is a +1 shifted log2 dim(mgs) ## [1] 250 32 2.5 mgs constructe module mgs_t &lt;- mgs %&gt;% t() # Samples as rows, Features as columns 2.5.1 select power powers &lt;- c(1:10, seq(12,20,2)) # default suppressWarnings(sft &lt;- pickSoftThreshold(mgs_t, powerVector = powers, verbose = 1, networkType = &quot;signed&quot;, corFn= &quot;bicor&quot;)) ## pickSoftThreshold: will use block size 250. ## pickSoftThreshold: calculating connectivity for given powers... \b..0% \b\b\b\b\b..100% ## Power SFT.R.sq slope truncated.R.sq mean.k. median.k. max.k. ## 1 1 0.6250 10.900 0.768 134.00 135.000 150.00 ## 2 2 0.6400 4.310 0.814 75.60 75.700 93.20 ## 3 3 0.5870 2.560 0.867 44.70 44.700 60.90 ## 4 4 0.3110 1.210 0.715 27.80 27.900 41.70 ## 5 5 0.2170 0.761 0.623 18.20 17.900 29.70 ## 6 6 0.2000 0.561 0.699 12.50 12.100 21.80 ## 7 7 0.1940 0.438 0.730 9.05 8.830 16.40 ## 8 8 0.0156 0.114 0.753 6.80 6.510 13.60 ## 9 9 0.0476 -0.223 0.620 5.30 4.830 11.80 ## 10 10 0.1870 -0.526 0.470 4.26 3.720 10.50 ## 11 12 0.5040 -0.857 0.661 2.99 2.310 8.89 ## 12 14 0.6820 -0.965 0.666 2.27 1.470 7.93 ## 13 16 0.7330 -1.080 0.659 1.84 1.070 7.33 ## 14 18 0.8160 -1.020 0.804 1.57 0.777 6.94 ## 15 20 0.8010 -0.986 0.808 1.38 0.587 6.67 # Find the soft thresholding power beta to which co-expression similarity is raised to calculate adjacency. # based on the criterion of approximate scale-free topology. idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.90)) if(is.infinite(idx)){ idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.80)) if(!is.infinite(idx)){ st &lt;- sft$fitIndices[idx,1] } else{ idx &lt;- which.max(-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) st &lt;- sft$fitIndices[idx,1] } } else{ st &lt;- sft$fitIndices[idx,1] } # Plot Scale independence measure and Mean connectivity measure # Scale-free topology fit index as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], sfApprox = -sign(sft$fitIndices[,3])*sft$fitIndices[,2]) %&gt;% ggplot() + geom_hline(yintercept = 0.9, color = &quot;red&quot;, alpha = 0.6) + # corresponds to R^2 cut-off of 0.9 geom_hline(yintercept = 0.8, color = &quot;red&quot;, alpha = 0.2) + # corresponds to R^2 cut-off of 0.8 geom_line(aes(x = Indices, y = sfApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = sfApprox, label = Indices), color = &quot;red&quot;, size = 4) + ggtitle(&quot;Scale independence&quot;) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;SF Model Fit,signed R^2&quot;) + xlim(1,20) + ylim(-1,1) + geom_segment(aes(x = st, y = 0.25, xend = st, yend = sfApprox[idx]-0.05), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.5)-&gt; scale_independence_plot # Mean connectivity as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], meanApprox = sft$fitIndices[,5]) %&gt;% ggplot() + geom_line(aes(x = Indices, y = meanApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = meanApprox, label = Indices), color = &quot;red&quot;, size = 4) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;Mean Connectivity&quot;) + geom_segment(aes(x = st-0.4, y = sft$fitIndices$mean.k.[idx], xend = 0, yend = sft$fitIndices$mean.k.[idx]), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.4) + ggtitle(paste0(&quot;Mean connectivity: &quot;, round(sft$fitIndices$mean.k.[idx],2))) -&gt; mean_connectivity_plot cowplot::plot_grid(scale_independence_plot, mean_connectivity_plot, ncol = 2, align = &quot;h&quot;, labels = c(&quot;A&quot;, &quot;B&quot;), label_size = 15) -&gt; si_mc_plot si_mc_plot The number closest to the 0.8 line is 18, and the constructed adjacency matrix most closely fits with scale-free topology. Therefore power is 18. 2.5.2 Block-wise network construction and module detection The function blockwiseModules will first pre cluster with fast crude clustering method to cluster OTUs into blocks not exceeding the maximum, blocks may therefore not be fully optimal in the end. Change the parameters here to better reflect your own data. if(!dir.exists(&quot;./result/&quot;)) { dir.create(&quot;./result/&quot;) } Run_analysis &lt;- TRUE if(Run_analysis){ modules.mgs &lt;- blockwiseModules(mgs_t, power = st, networkType = &quot;signed&quot;, TOMType = &quot;signed&quot;, corType = &#39;bicor&#39;, maxPOutliers = 0.05, deepSplit = 2, pamStage = FALSE, pamRespectsDendro = TRUE, mergeCutHeight = 0.25, replaceMissingAdjacencies = TRUE, minModuleSize = 5, # There are fewer otus than genes, and that many might not be connected numericLabels = TRUE, saveTOMs = TRUE, saveTOMFileBase = &quot;./result/modules.mgs&quot;, #&quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/GVHD/bookdown_GVHD/result/modules.mgs&quot;, verbose = 1) rownames(modules.mgs$MEs) &lt;- rownames(mgs_t) names(modules.mgs$colors) &lt;- colnames(mgs_t) names(modules.mgs$unmergedColors) &lt;- colnames(mgs_t) hubs.mgs &lt;- chooseTopHubInEachModule(mgs_t, modules.mgs$colors) } ## Calculating module eigengenes block-wise from all genes 2.5.3 mgs module details # Convert labels to colors for plotting merged_colors &lt;- labels2colors(modules.mgs$colors) All samples are OK. All OTUs are OK. There where 8 modules found. All module eigenOTUs are OK. How many OTUs are there in each module? table(modules.mgs$colors) %&gt;% as.data.frame() %&gt;% dplyr::rename(Module = Var1, Size = Freq) %&gt;% dplyr::mutate(Module_color = labels2colors(as.numeric(as.character(Module)))) -&gt; module_size module_size %&gt;% ggplot(aes(x = Module, y = Size, fill = Module)) + geom_col(color = &quot;#000000&quot;) + ggtitle(&quot;Number of OTUs in each module&quot;) + theme(legend.position = &quot;none&quot;) + scale_fill_manual(values = setNames(module_size$Module_color,module_size$Module)) + geom_text(aes(label = Size),vjust = 0.5, hjust = -0.18, size = 3.5) + ylim(0, max(module_size$Size)*1.1) + theme(plot.margin = margin(2, 2, 2, 2, &quot;pt&quot;)) + coord_flip()-&gt; module_size_barplot module_size_barplot cluster relationships between the module # labels2colors(modules.mgs$colors) plotEigengeneNetworks(modules.mgs$MEs, &quot;Eigengene adjacency heatmap&quot;, marDendro = c(3,3,2,4), marHeatmap = c(3,4,2,2), plotDendrograms = T, xLabelsAngle = 90) table(modules.mgs$colors) %&gt;% as.data.frame() -&gt; res res$`Module color` &lt;- WGCNA::labels2colors(as.numeric(as.character(res$Var1))) res &lt;- res[, c(1,3,2)] colnames(res) &lt;- c(&quot;Module&quot;, &quot;Module color&quot;, &quot;Number of OTUs&quot;) res %&gt;% datatable() Dendrogram and module colors # Plot the dendrogram and the module colors underneath for each block for(i in seq_along(modules.mgs$dendrograms)){ plotDendroAndColors(modules.mgs$dendrograms[[i]], merged_colors[modules.mgs$blockGenes[[i]]], &quot;Module colors&quot;, dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = paste0(&quot;Cluster Dendrogram\\n&quot;, &quot;for block &quot;, i,&quot;: &quot;, length(modules.mgs$blockGenes[[i]]), &quot; OTUs&quot;)) } Module (Eigengene) correlation MEs &lt;- modules.mgs$MEs # Module correlation to other modules MEs_R &lt;- bicor(MEs, MEs, maxPOutliers = 0.05) ## Warning in bicor(MEs, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;x&#39;. Pearson correlation ## was used for individual columns with zero (or missing) MAD. ## Warning in bicor(MEs, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;y&#39;. Pearson correlation ## was used for individual columns with zero (or missing) MAD. idx.r &lt;- which(rownames(MEs_R) == &quot;ME0&quot;) idx.c &lt;- which(colnames(MEs_R) == &quot;ME0&quot;) MEs_R_noME0 &lt;- MEs_R[-idx.r, -idx.c] MEs_R[upper.tri(MEs_R_noME0)] %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;correlation&quot; = &quot;.&quot;) %&gt;% ggplot(aes(x=correlation)) + geom_density() + ggtitle(paste0(&quot;mgs&quot;,&quot;ME correlation density\\n without &quot;,&quot;mgs&quot; ,&quot;ME0&quot;)) -&gt; MEs_R_density pheatmap::pheatmap(MEs_R, color = colorRampPalette(c(&quot;Blue&quot;, &quot;White&quot;, &quot;Red&quot;))(100), silent = T, breaks = seq(-1,1,length.out = 101), treeheight_row = 5, treeheight_col = 5, main = paste0(&quot;mgs&quot;,&quot;ME correlation heatmap&quot;), labels_row = paste0(&quot;mgs&quot;, rownames(MEs_R)), labels_col = paste0(&quot;mgs&quot;, colnames(MEs_R))) -&gt; MEs_R_Corr cowplot::plot_grid(MEs_R_density, MEs_R_Corr$gtable, labels = c(&quot;D&quot;, &quot;E&quot;), label_size = 15, rel_widths = c(0.6, 1)) -&gt; density_eigen density_eigen all(rownames(mgs_t) == rownames(MEs)) ## [1] TRUE dim(mgs_t) %&gt;% paste0(c(&quot; samples&quot;, &quot; OTUs&quot;)) ## [1] &quot;32 samples&quot; &quot;250 OTUs&quot; kME &lt;- bicor(mgs_t, MEs, maxPOutliers = 0.05) dim(kME) %&gt;% paste0(c(&quot; OTUs&quot;, &quot; modules&quot;)) ## [1] &quot;250 OTUs&quot; &quot;8 modules&quot; Show a plot of the intra modular correlation; How the OTUs within a module correlates to the module eigengene. intra_cor &lt;- c() for (i in 1:ncol(mgs_t)) { m &lt;- modules.mgs$colors[i] intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] if(m != 0){ intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] } else{ intra_cor[i] &lt;- NA } } idx &lt;- which(is.na(intra_cor)) intra_cor &lt;- intra_cor[-idx] plot(density(intra_cor), main = &quot;Correlations with module-eigenOTU (within module correlation)\\nNo ME0&quot;, xlim = c(-1,1)) Show the same thing, but for each module individually, and color by module color. # Corr within modules corr_within_module &lt;- function(mgs_t, modules, module_x = 1){ idx.omics_data &lt;- which(modules$colors == module_x) idx.me &lt;- which(colnames(modules$MEs) == paste0(&quot;ME&quot;,module_x)) kME_x &lt;- bicor(mgs_t[,idx.omics_data], modules$MEs[,idx.me], maxPOutliers = 0.05) kME_x } ggplot.list &lt;- list() for(m in colnames(modules.mgs$MEs)){ h &lt;- as.numeric(sub(&quot;ME&quot;,&quot;&quot;, m)) data.frame(x = suppressWarnings(corr_within_module(mgs_t = mgs_t, modules = modules.mgs, module_x = h))) %&gt;% ggplot() + geom_density(aes(x = x), fill = labels2colors(h), color = &quot;black&quot;, alpha = 0.5) + xlim(-1, 1) + xlab(&quot;OTU correlation&quot;)+ ggtitle(paste0(&quot;mgs&quot;,m)) -&gt; da_plot ggplot.list[[m]] &lt;- da_plot } ggplot.list &lt;- ggplot.list[ggplot.list %&gt;% names() %&gt;% sub(&quot;ME&quot;, &quot;&quot;, .) %&gt;% as.numeric() %&gt;% order()] cowplot::plot_grid(plotlist = ggplot.list, ncol = 2) -&gt; density_all_plot density_all_plot Combine to one plot cowplot::plot_grid(si_mc_plot , density_eigen, ncol = 1, rel_heights = c(0.8,1)) -&gt; part_1 cowplot::plot_grid(part_1, module_size_barplot, labels = c(&quot;&quot;, &quot;C&quot;), label_size = 15, rel_widths = c(1,0.5)) -&gt; part_2 cowplot::plot_grid(part_2, density_all_plot, ncol = 1, rel_heights = c(0.8,1), labels = c(&quot;&quot;, &quot;F&quot;), label_size = 15) Hub genes For each module it is possible to pick a hub gene with the function chooseTopHubInEachModule. hubs.mgs %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;OTU_name&quot; = &quot;.&quot;) %&gt;% tibble::rownames_to_column(var = &quot;Module&quot;) -&gt; hubOTUs dplyr::left_join(hubOTUs, (taxa_table %&gt;% tibble::rownames_to_column(var = &quot;OTU_name&quot;)), by = &quot;OTU_name&quot;) -&gt; hubOTUs hubOTUs %&gt;% datatable() 2.6 metabolites constructe module metabolites_t &lt;- metabolites_data %&gt;% t() 2.6.1 select power powers &lt;- c(1:10, seq(12,20,2)) suppressWarnings(sft &lt;- pickSoftThreshold(metabolites_t, powerVector = powers, verbose = 1, networkType = &quot;signed&quot;, corFn= &quot;bicor&quot;)) ## pickSoftThreshold: will use block size 811. ## pickSoftThreshold: calculating connectivity for given powers... \b..0% \b\b\b\b\b..100% ## Power SFT.R.sq slope truncated.R.sq mean.k. median.k. max.k. ## 1 1 0.72200 9.9100 0.756 456.00 462.00 520.0 ## 2 2 0.79300 4.6000 0.924 273.00 278.00 345.0 ## 3 3 0.75800 2.8500 0.951 172.00 175.00 238.0 ## 4 4 0.57200 1.7000 0.941 113.00 113.00 176.0 ## 5 5 0.26700 0.7160 0.932 76.60 76.00 134.0 ## 6 6 0.00268 0.0619 0.861 53.80 52.30 108.0 ## 7 7 0.11500 -0.3880 0.920 38.90 36.70 89.5 ## 8 8 0.30800 -0.7520 0.901 28.90 26.60 75.3 ## 9 9 0.41300 -0.9160 0.918 22.00 19.40 64.3 ## 10 10 0.53800 -1.2300 0.901 17.00 14.50 55.5 ## 11 12 0.64600 -1.5400 0.935 10.80 8.60 42.5 ## 12 14 0.71500 -1.6400 0.954 7.32 5.48 33.4 ## 13 16 0.75500 -1.6800 0.960 5.23 3.52 26.8 ## 14 18 0.77000 -1.7300 0.946 3.90 2.49 21.9 ## 15 20 0.74400 -1.7800 0.912 3.03 1.74 18.1 # Find the soft thresholding power beta to which co-expression similarity is raised to calculate adjacency. # based on the criterion of approximate scale-free topology. idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.90)) if(is.infinite(idx)){ idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.80)) if(!is.infinite(idx)){ st &lt;- sft$fitIndices[idx,1] } else{ idx &lt;- which.max(-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) st &lt;- sft$fitIndices[idx,1] } } else{ st &lt;- sft$fitIndices[idx,1] } # Plot Scale independence measure and Mean connectivity measure # Scale-free topology fit index as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], sfApprox = -sign(sft$fitIndices[,3])*sft$fitIndices[,2]) %&gt;% ggplot() + geom_hline(yintercept = 0.9, color = &quot;red&quot;, alpha = 0.6) + # corresponds to R^2 cut-off of 0.9 geom_hline(yintercept = 0.8, color = &quot;red&quot;, alpha = 0.2) + # corresponds to R^2 cut-off of 0.8 geom_line(aes(x = Indices, y = sfApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = sfApprox, label = Indices), color = &quot;red&quot;, size = 4) + ggtitle(&quot;Scale independence&quot;) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;SF Model Fit,signed R^2&quot;) + xlim(1,20) + ylim(-1,1) + geom_segment(aes(x = st, y = 0.25, xend = st, yend = sfApprox[idx]-0.05), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.5)-&gt; scale_independence_plot # Mean connectivity as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], meanApprox = sft$fitIndices[,5]) %&gt;% ggplot() + geom_line(aes(x = Indices, y = meanApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = meanApprox, label = Indices), color = &quot;red&quot;, size = 4) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;Mean Connectivity&quot;) + geom_segment(aes(x = st-0.4, y = sft$fitIndices$mean.k.[idx], xend = 0, yend = sft$fitIndices$mean.k.[idx]), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.4) + ggtitle(paste0(&quot;Mean connectivity: &quot;, round(sft$fitIndices$mean.k.[idx],2))) -&gt; mean_connectivity_plot cowplot::plot_grid(scale_independence_plot, mean_connectivity_plot, ncol = 2, align = &quot;h&quot;, labels = c(&quot;A&quot;, &quot;B&quot;), label_size = 15) -&gt; si_mc_plot si_mc_plot The power is 18 2.6.2 Block-wise network construction and module detection The function blockwiseModules will first pre cluster with fast crude clustering method to cluster OTUs into blocks not exceeding the maximum, blocks may therefore not be fully optimal in the end. Change the parameters here to better reflect your own data. Run_analysis &lt;- TRUE if(Run_analysis){ modules.metabolites &lt;- blockwiseModules(metabolites_t, power = st, networkType = &quot;signed&quot;, TOMType = &quot;signed&quot;, corType = &#39;bicor&#39;, maxPOutliers = 0.05, deepSplit = 2, pamStage = FALSE, pamRespectsDendro = TRUE, mergeCutHeight = 0.25, replaceMissingAdjacencies = TRUE, minModuleSize = 5, # There are fewer otus than genes, and that many might not be connected numericLabels = TRUE, saveTOMs = TRUE, saveTOMFileBase = &quot;./result/module.metabolites&quot;, #&quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/GVHD/bookdown_GVHD/result/module.metabolites&quot;, verbose = 1) rownames(modules.metabolites$MEs) &lt;- rownames(metabolites_t) names(modules.metabolites$colors) &lt;- colnames(metabolites_t) names(modules.metabolites$unmergedColors) &lt;- colnames(metabolites_t) hubs.metabolites &lt;- chooseTopHubInEachModule(metabolites_t, modules.metabolites$colors) } ## Calculating module eigengenes block-wise from all genes 2.6.3 metabolites module details # Convert labels to colors for plotting merged_colors &lt;- labels2colors(modules.metabolites$colors) All samples are OK. All OTUs are OK. There where 27 modules found. All module eigenOTUs are OK. How many Metabolites are there in each module? table(modules.metabolites$colors) %&gt;% as.data.frame() %&gt;% dplyr::rename(Module = Var1, Size = Freq) %&gt;% dplyr::mutate(Module_color = labels2colors(as.numeric(as.character(Module)))) -&gt; module_size module_size %&gt;% ggplot(aes(x = Module, y = Size, fill = Module)) + geom_col(color = &quot;#000000&quot;) + ggtitle(&quot;Number of Metabolites in each module&quot;) + theme(legend.position = &quot;none&quot;) + scale_fill_manual(values = setNames(module_size$Module_color,module_size$Module)) + geom_text(aes(label = Size),vjust = 0.5, hjust = -0.18, size = 3.5) + ylim(0, max(module_size$Size)*1.1) + theme(plot.margin = margin(2, 2, 2, 2, &quot;pt&quot;)) + coord_flip()-&gt; module_size_barplot module_size_barplot cluster relationships between the module # labels2colors(modules.metabolites$colors) plotEigengeneNetworks(modules.metabolites$MEs, &quot;Eigengene adjacency heatmap&quot;, marDendro = c(3,3,2,4), marHeatmap = c(3,4,2,2), plotDendrograms = T, xLabelsAngle = 90) table(modules.metabolites$colors) %&gt;% as.data.frame() -&gt; res res$`Module color` &lt;- WGCNA::labels2colors(as.numeric(as.character(res$Var1))) res &lt;- res[, c(1,3,2)] colnames(res) &lt;- c(&quot;Module&quot;, &quot;Module color&quot;, &quot;Number of metabolic&quot;) res %&gt;% datatable() Dendrogram and module colors # Plot the dendrogram and the module colors underneath for each block for(i in seq_along(modules.metabolites$dendrograms)){ plotDendroAndColors(modules.metabolites$dendrograms[[i]], merged_colors[modules.metabolites$blockGenes[[i]]], &quot;Module colors&quot;, dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = paste0(&quot;Cluster Dendrogram\\n&quot;, &quot;for block &quot;, i,&quot;: &quot;, length(modules.metabolites$blockGenes[[i]]), &quot; metabolic&quot;)) } Module (Eigengene) correlation MEs &lt;- modules.metabolites$MEs # Module correlation to other modules MEs_R &lt;- bicor(MEs, MEs, maxPOutliers = 0.05) idx.r &lt;- which(rownames(MEs_R) == &quot;ME0&quot;) idx.c &lt;- which(colnames(MEs_R) == &quot;ME0&quot;) MEs_R_noME0 &lt;- MEs_R[-idx.r, -idx.c] MEs_R[upper.tri(MEs_R_noME0)] %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;correlation&quot; = &quot;.&quot;) %&gt;% ggplot(aes(x=correlation)) + geom_density() + ggtitle(paste0(&quot;mbs&quot;,&quot;ME correlation density\\n without &quot;,&quot;mbs&quot; ,&quot;ME0&quot;)) -&gt; MEs_R_density pheatmap::pheatmap(MEs_R, color = colorRampPalette(c(&quot;Blue&quot;, &quot;White&quot;, &quot;Red&quot;))(100), silent = T, breaks = seq(-1,1,length.out = 101), treeheight_row = 5, treeheight_col = 5, main = paste0(&quot;mbs&quot;,&quot;ME correlation heatmap&quot;), labels_row = paste0(&quot;mbs&quot;, rownames(MEs_R)), labels_col = paste0(&quot;mbs&quot;, colnames(MEs_R))) -&gt; MEs_R_Corr cowplot::plot_grid(MEs_R_density, MEs_R_Corr$gtable, labels = c(&quot;D&quot;, &quot;E&quot;), label_size = 15, rel_widths = c(0.6, 1)) -&gt; density_eigen density_eigen all(rownames(metabolites_t) == rownames(MEs)) ## [1] TRUE dim(metabolites_t) %&gt;% paste0(c(&quot; samples&quot;, &quot; metabolic&quot;)) ## [1] &quot;32 samples&quot; &quot;811 metabolic&quot; kME &lt;- bicor(metabolites_t, MEs, maxPOutliers = 0.05) dim(kME) %&gt;% paste0(c(&quot; metabolic&quot;, &quot; modules&quot;)) ## [1] &quot;811 metabolic&quot; &quot;27 modules&quot; Show a plot of the intra modular correlation; How the OTUs within a module correlates to the module eigengene. intra_cor &lt;- c() for (i in 1:ncol(metabolites_t)) { m &lt;- modules.metabolites$colors[i] intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] if(m != 0){ intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] } else{ intra_cor[i] &lt;- NA } } idx &lt;- which(is.na(intra_cor)) intra_cor &lt;- intra_cor[-idx] plot(density(intra_cor), main = &quot;Correlations with module-eigenMBS (within module correlation)\\nNo ME0&quot;, xlim = c(-1,1)) Show the same thing, but for each module individually, and color by module color. # Corr within modules corr_within_module &lt;- function(metabolites_t, modules, module_x = 1){ idx.omics_data &lt;- which(modules$colors == module_x) idx.me &lt;- which(colnames(modules$MEs) == paste0(&quot;ME&quot;,module_x)) kME_x &lt;- bicor(metabolites_t[,idx.omics_data], modules$MEs[,idx.me], maxPOutliers = 0.05) kME_x } ggplot.list &lt;- list() for(m in colnames(modules.metabolites$MEs)){ h &lt;- as.numeric(sub(&quot;ME&quot;,&quot;&quot;, m)) data.frame(x = suppressWarnings(corr_within_module(metabolites_t = metabolites_t, modules = modules.metabolites, module_x = h))) %&gt;% ggplot() + geom_density(aes(x = x), fill = labels2colors(h), color = &quot;black&quot;, alpha = 0.5) + xlim(-1, 1) + xlab(&quot;metabolic correlation&quot;)+ ggtitle(paste0(&quot;mbs&quot;,m)) -&gt; da_plot ggplot.list[[m]] &lt;- da_plot } ggplot.list &lt;- ggplot.list[ggplot.list %&gt;% names() %&gt;% sub(&quot;ME&quot;, &quot;&quot;, .) %&gt;% as.numeric() %&gt;% order()] cowplot::plot_grid(plotlist = ggplot.list, ncol = 5) -&gt; density_all_plot # ncol 可以根据module的大小调整 density_all_plot Combine to one plot cowplot::plot_grid(si_mc_plot , density_eigen, ncol = 1, rel_heights = c(0.8,1)) -&gt; part_1 cowplot::plot_grid(part_1, module_size_barplot, labels = c(&quot;&quot;, &quot;C&quot;), label_size = 15, rel_widths = c(1,0.5)) -&gt; part_2 cowplot::plot_grid(part_2, density_all_plot, ncol = 1, rel_heights = c(0.8,1), labels = c(&quot;&quot;, &quot;F&quot;), label_size = 15) Hub metabolic For each module it is possible to pick a hub metabolic with the function chooseTopHubInEachModule. hubs.metabolites %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;mbs_name&quot; = &quot;.&quot;) %&gt;% tibble::rownames_to_column(var = &quot;Module&quot;) -&gt; hubMBS dplyr::left_join(hubMBS, (metabolites_level %&gt;% tibble::rownames_to_column(var = &quot;mbs_name&quot;)), by = &quot;mbs_name&quot;) -&gt; hubMBS hubMBS %&gt;% datatable() 2.7 metabolites, mgs and metadata association X_eigengenes &lt;- modules.metabolites$MEs # X_eigengenes is metabolic Y_eigengenes &lt;- modules.mgs$MEs # Y_eigengenes is mgs # Create a dendrogram of the metabolites eigengenes to organise the final plots. X_ME_dendro &lt;- hclust(as.dist(1 - WGCNA::bicor(X_eigengenes, maxPOutliers = 0.05)), method = &quot;ward.D2&quot;) heatmap_colors &lt;- colorRampPalette(c(&quot;#18b29f&quot;,&quot;#FFFFFF&quot;,&quot;#ac6721&quot;), interpolate = &quot;spline&quot;, space = &quot;rgb&quot;)(51) annotation_col &lt;- metadata %&gt;% t() %&gt;% as.data.frame() %&gt;% select(V1_outcome, GVHD_type, Donor) annotation_colors &lt;- list( V1_outcome = c(`CR` = &quot;#F08A46&quot;, `PR` = &quot;#8EB470&quot;, `NR` = &quot;#B7CFA4&quot;), GVHD_type = c(`aGVHD` = &quot;red&quot;, `cGVHD` = &quot;green&quot;), Donor = c(`DO1` = &quot;paleturquoise&quot;, `DO2` = &quot;palevioletred&quot;) ) X_eigengenes_to_plot &lt;- dplyr::inner_join(annotation_col %&gt;% rownames_to_column(var = &quot;sampleName&quot;), X_eigengenes %&gt;% rownames_to_column(var = &quot;sampleName&quot;), by = &quot;sampleName&quot;) %&gt;% dplyr::arrange(V1_outcome, GVHD_type, Donor) %&gt;% # The order at which the columns should appear, given that there is no clustering. dplyr::select(sampleName, starts_with(&quot;ME&quot;)) %&gt;% tibble::column_to_rownames(var = &quot;sampleName&quot;) %&gt;% t() pheatmap::pheatmap(X_eigengenes_to_plot, cluster_cols = TRUE, cluster_rows = X_ME_dendro, treeheight_row = 20, cutree_rows = 4, cutree_cols = 4, color = heatmap_colors, fontsize = 10, fontsize_col = 6, annotation_colors = annotation_colors, annotation_col = annotation_col, silent = F, labels_row = paste0(&quot;mb&quot;, rownames(X_eigengenes_to_plot)), main = paste(&quot;Metabolites Module &#39;expression&#39;\\n&quot;)) -&gt; X_plot 2.7.0.1 Correlate modules from metabolic and metagenomics. p.value_matr &lt;- corr.value_matr &lt;- matrix(ncol = ncol(Y_eigengenes), nrow = ncol(X_eigengenes), dimnames = list(colnames(X_eigengenes), colnames(Y_eigengenes))) for(i in 1:ncol(X_eigengenes)){ for(j in 1:ncol(Y_eigengenes)){ cor.res &lt;- cor.test(X_eigengenes[,i], Y_eigengenes[,j]) p.value_matr[i, j] &lt;- cor.res$p.value corr.value_matr[i, j] &lt;- cor.res$estimate } } # Correct for number of tests p.value_matr.adjust &lt;- p.adjust(p.value_matr, method = &quot;fdr&quot;) dim(p.value_matr.adjust) &lt;- dim(p.value_matr) dimnames(p.value_matr.adjust) &lt;- list(colnames(X_eigengenes), colnames(Y_eigengenes)) # Add significance level. # One star means a p-value of less than 0.05; Two stars is less than 0.01, and three, is less than 0.001. signif_matrix &lt;- rep(&quot;&quot;, length(p.value_matr)) three_star &lt;- which( p.value_matr &lt;= 0.001) signif_matrix[three_star] &lt;- &quot;***&quot; two_star &lt;- which((p.value_matr &lt;= 0.01) &amp; (p.value_matr &gt; 0.001)) signif_matrix[two_star] &lt;- &quot;**&quot; one_star &lt;- which((p.value_matr &lt;= 0.05) &amp; (p.value_matr &gt; 0.01)) signif_matrix[one_star] &lt;- &quot;*&quot; dim(signif_matrix) = dim(p.value_matr) # Give textMatrix the correct dimensions # Collect all results into a list. Y_corr_X &lt;- list(p_value = p.value_matr, p_value_adj = p.value_matr.adjust, signif_matrix = signif_matrix, correlation = corr.value_matr) rm(p.value_matr, p.value_matr.adjust, signif_matrix, corr.value_matr) heatmap_colors &lt;- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 6, name =&quot;RdBu&quot;)))(51) pheatmap::pheatmap(Y_corr_X$correlation, color = heatmap_colors, treeheight_col = 0, treeheight_row = 0, # will be shown on the transcriptomics ME heatmap cluster_rows = X_ME_dendro, cutree_rows = 4, display_numbers = Y_corr_X$signif_matrix, fontsize_number = 10, breaks = seq(from = -1, to = 1, length.out = 51), silent = F, show_rownames = F, labels_row = paste0(&quot;mg&quot;, rownames(Y_corr_X$correlation)), labels_col = paste0(&quot;mg&quot;, colnames(Y_corr_X$correlation)), main = &quot;EigenOTUs&quot;) -&gt; Y_corr_X_plot 2.7.0.2 Combine heatmaps cowplot::plot_grid(Y_corr_X_plot$gtable, X_plot$gtable, ncol = 2, rel_widths = c(dim(Y_eigengenes)[2]/3, dim(X_eigengenes)[1]/9), align = &quot;h&quot;) + ggplot2::theme(plot.margin = ggplot2::unit(c(3,0,2.5,1), &quot;cm&quot;)) 2.8 Visualization network The strong correlation between mgME3 and mbME1 is the modules of interest, and we wondered if they contain those bacteria and metabolites, which ara published in the existing literature, or if there is a potential mining value. So we visualize network in mgME3 and mbME1 (In the practical application，find the module you are interested in for visualization) Visualize mgME3 #load(file = &quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/GVHD/bookdown_GVHD/result/modules.mgs-block.1.RData&quot;) load(file = &quot;./result/modules.mgs-block.1.RData&quot;) # The TOM is saved as a dist object and needs to be converted to a matrix TOM &lt;- as.matrix(TOM) # Add OTU names to the TOM matrix. It is symmetrical so rownames = colnames rownames(TOM) &lt;- colnames(TOM) &lt;- names(modules.mgs$colors) Which taxonomic level should the graph be colored with in addition to modules? selected_taxa &lt;- &quot;Genus&quot; Convert module labels and taxonomy to hex colors taxonomy_info &lt;- taxa_table %&gt;% rownames_to_column(var = &quot;OTU_name&quot;) %&gt;% dplyr::select(&quot;OTU_name&quot;, selected_taxa) %&gt;% mutate_all(.funs = list(as.character)) module_info &lt;- modules.mgs$colors %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;OTU_name&quot;) %&gt;% dplyr::rename(Module = &quot;.&quot;) %&gt;% filter(Module == 3) # selected module, here is ME3 TOM &lt;- TOM[module_info$OTU_name, module_info$OTU_name] graph_info &lt;- left_join(module_info, taxonomy_info, by = &quot;OTU_name&quot;) # Converts R-colors to hex colors color2hex &lt;- function(x){ x &lt;- col2rgb(x) rgb(x[1,], x[2,], x[3,], maxColorValue = 255) } # Add specific colors to the taxa taxa_colors &lt;- graph_info %&gt;% dplyr::select(selected_taxa) %&gt;% unique() %&gt;% mutate(tax_color = colorRampPalette(RColorBrewer::brewer.pal(8, &quot;Accent&quot;))(nrow(.))) graph_info_colors &lt;- left_join(graph_info, taxa_colors) %&gt;% mutate(module_color = WGCNA::labels2colors(Module)) %&gt;% mutate(module_color = color2hex(module_color)) %&gt;% mutate(module_color = paste0(module_color,70)) ## Joining, by = &quot;Genus&quot; If all lines are too thick, reduce the strength (between 0 and 1). The lower the number the weaker the lines. strength_adjust = 1 g &lt;- graph.adjacency(TOM, mode=&quot;undirected&quot;, weighted= TRUE) #~https://stackoverflow.com/questions/28366329/how-to-scale-edge-colors-igraph igraph::delete.edges(g, which(E(g)$weight &lt;1)) ## IGRAPH 64de29f UNW- 12 0 -- ## + attr: name (v/c), weight (e/n) ## + edges from 64de29f (vertex names): E(g)$width &lt;- E(g)$weight*strength_adjust + min(E(g)$weight) E(g)$color &lt;- &quot;red&quot; set.seed(231) # Ensures the same layout given the same data. l &lt;- layout_with_fr(g, weights = E(g)$weight) # Order graph_info_colors by the graph graph_info_colors &lt;- graph_info_colors[which(graph_info_colors$OTU_name %in% V(g)$name),] # Ensure that the names are in the same order if(all(V(g)$name == graph_info_colors$OTU_name)){cat(&quot;\\nOTU names match&quot;)} ## ## OTU names match # Add square shapes to hub OTUs V(g)$shape &lt;- ifelse(V(g)$name %in% hubs.mgs[-1], &quot;square&quot;, &quot;circle&quot;) #-1 means dont use module 0 # OTUs in modules have larger nodes V(g)$size &lt;- ifelse(graph_info_colors$Module != 0, 10, 5) # And larger text V(g)$label.cex &lt;- ifelse(graph_info_colors$Module != 0, 0.8, 0.4) # Remove everything but the number to increase readability V(g)$name = sub(&quot;OTU_&quot;, &quot;&quot;, graph_info_colors$OTU_name) Find distinct entires for the plot legends module_labels &lt;- graph_info_colors %&gt;% dplyr::select(Module, module_color) %&gt;% distinct() %&gt;% arrange(Module) tax_labels &lt;- graph_info_colors %&gt;% dplyr::select(selected_taxa, tax_color) %&gt;% distinct() Plot the graphs, leftmost is colored by module, rightmost is colored by taxonomic classification par(mfrow = c(1,2)) par(mar = c(0,0,0,0)) # plot(g, layout = l, vertex.color = graph_info_colors$module_color) # # legend(&quot;topleft&quot;, legend = paste0(&quot;mM&quot;, 0:(nrow(module_labels)-1)), fill=module_labels$module_color) # legend(&quot;topleft&quot;, legend = paste0(&quot;mgsM&quot;, 3), fill=module_labels$module_color) plot(g, layout = l, vertex.color = graph_info_colors$tax_color) legend(&quot;topleft&quot;, legend = tax_labels$Genus, fill=tax_labels$tax_color) par(mfrow = c(1,1)) Visualize mbME1 #load(file = &quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/GVHD/bookdown_GVHD/result/module.metabolites-block.1.RData&quot;) load(file = &quot;./result/module.metabolites-block.1.RData&quot;) # The TOM is saved as a dist object and needs to be converted to a matrix TOM &lt;- as.matrix(TOM) # Add OTU names to the TOM matrix. It is symmetrical so rownames = colnames rownames(TOM) &lt;- colnames(TOM) &lt;- names(modules.metabolites$colors) Which metabolic level should the graph be colored with in addition to modules? selected_taxa &lt;- &quot;Class.II&quot; Convert module labels and taxonomy to hex colors taxonomy_info &lt;- metabolites_level %&gt;% rownames_to_column(var = &quot;mbs_name&quot;) %&gt;% dplyr::select(&quot;mbs_name&quot;, selected_taxa) %&gt;% mutate_all(.funs = list(as.character)) module_info &lt;- modules.metabolites$colors %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;mbs_name&quot;) %&gt;% dplyr::rename(Module = &quot;.&quot;) %&gt;% filter(Module == 1) # selected module, here is ME1 TOM &lt;- TOM[module_info$mbs_name, module_info$mbs_name] graph_info &lt;- left_join(module_info, taxonomy_info, by = &quot;mbs_name&quot;) # Converts R-colors to hex colors color2hex &lt;- function(x){ x &lt;- col2rgb(x) rgb(x[1,], x[2,], x[3,], maxColorValue = 255) } # Add specific colors to the taxa taxa_colors &lt;- graph_info %&gt;% dplyr::select(selected_taxa) %&gt;% unique() %&gt;% mutate(tax_color = colorRampPalette(RColorBrewer::brewer.pal(8, &quot;Accent&quot;))(nrow(.))) graph_info_colors &lt;- left_join(graph_info, taxa_colors) %&gt;% mutate(module_color = WGCNA::labels2colors(Module)) %&gt;% mutate(module_color = color2hex(module_color)) %&gt;% mutate(module_color = paste0(module_color,70)) ## Joining, by = &quot;Class.II&quot; If all lines are too thick, reduce the strength (between 0 and 1). The lower the number the weaker the lines. strength_adjust = 0.2 g &lt;- graph.adjacency(TOM, mode=&quot;undirected&quot;, weighted= TRUE) #~https://stackoverflow.com/questions/28366329/how-to-scale-edge-colors-igraph igraph::delete.edges(g, which(E(g)$weight &lt;1)) ## IGRAPH 6fb14af UNW- 54 0 -- ## + attr: name (v/c), weight (e/n) ## + edges from 6fb14af (vertex names): E(g)$width &lt;- E(g)$weight*strength_adjust + min(E(g)$weight) E(g)$color &lt;- &quot;red&quot; set.seed(231) # Ensures the same layout given the same data. l &lt;- layout_with_fr(g, weights = E(g)$weight) # Order graph_info_colors by the graph graph_info_colors &lt;- graph_info_colors[which(graph_info_colors$mbs_name %in% V(g)$name),] # Ensure that the names are in the same order if(all(V(g)$name == graph_info_colors$mbs_name)){cat(&quot;\\nmbs names match&quot;)} ## ## mbs names match # Add square shapes to hub OTUs V(g)$shape &lt;- ifelse(V(g)$name %in% hubs.metabolites[-1], &quot;square&quot;, &quot;circle&quot;) #-1 means dont use module 0 # OTUs in modules have larger nodes V(g)$size &lt;- ifelse(graph_info_colors$Module != 0, 10, 5) # And larger text V(g)$label.cex &lt;- ifelse(graph_info_colors$Module != 0, 0.8, 0.4) # Remove everything but the number to increase readability V(g)$name = sub(&quot;mbs_&quot;, &quot;&quot;, graph_info_colors$mbs_name) Find distinct entires for the plot legends module_labels &lt;- graph_info_colors %&gt;% dplyr::select(Module, module_color) %&gt;% distinct() %&gt;% arrange(Module) tax_labels &lt;- graph_info_colors %&gt;% dplyr::select(selected_taxa, tax_color) %&gt;% distinct() Plot the graphs, leftmost is colored by module, rightmost is colored by taxonomic classification par(mfrow = c(1,2)) par(mar = c(0,0,0,0)) # plot(g, layout = l, vertex.color = graph_info_colors$module_color) # # legend(&quot;topleft&quot;, legend = paste0(&quot;mM&quot;, 0:(nrow(module_labels)-1)), fill=module_labels$module_color) # legend(&quot;topleft&quot;, legend = paste0(&quot;mbM&quot;, 1), fill=module_labels$module_color) plot(g, layout = l, vertex.color = graph_info_colors$tax_color) legend(&quot;topright&quot;, legend = tax_labels$Class.II, fill=tax_labels$tax_color) par(mfrow = c(1,1)) 2.9 Session Info devtools::session_info() ## ─ Session info ──────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.3 (2020-02-29) ## os Ubuntu 16.04.7 LTS ## system x86_64, linux-gnu ## ui RStudio ## language (EN) ## collate en_IN.UTF-8 ## ctype en_IN.UTF-8 ## tz Asia/Hong_Kong ## date 2022-07-08 ## rstudio 1.1.419 (server) ## pandoc 2.7.3 @ /usr/bin/ (via rmarkdown) ## ## ─ Packages ──────────────────────────────────────────────────────────────────────────────────────── ## ! package * version date (UTC) lib source ## abind 1.4-5 2016-07-21 [2] CRAN (R 3.6.3) ## ade4 1.7-19 2022-04-19 [2] CRAN (R 3.6.3) ## annotate 1.64.0 2019-10-29 [2] Bioconductor ## AnnotationDbi 1.48.0 2019-10-29 [2] Bioconductor ## ape 5.6-2 2022-03-02 [2] CRAN (R 3.6.3) ## assertthat 0.2.1 2019-03-21 [2] CRAN (R 3.6.3) ## backports 1.4.1 2021-12-13 [2] CRAN (R 3.6.3) ## base64enc 0.1-3 2015-07-28 [2] CRAN (R 3.6.3) ## Biobase * 2.46.0 2019-10-29 [2] Bioconductor ## BiocGenerics * 0.32.0 2019-10-29 [2] Bioconductor ## BiocParallel * 1.20.1 2019-12-21 [2] Bioconductor ## biomformat 1.14.0 2019-10-29 [2] Bioconductor ## Biostrings 2.54.0 2019-10-29 [2] Bioconductor ## bit 4.0.4 2020-08-04 [2] CRAN (R 3.6.3) ## bit64 4.0.5 2020-08-30 [2] CRAN (R 3.6.3) ## bitops 1.0-7 2021-04-24 [2] CRAN (R 3.6.3) ## blob 1.2.3 2022-04-10 [2] CRAN (R 3.6.3) ## bookdown 0.27 2022-06-14 [1] CRAN (R 3.6.3) ## brio 1.1.3 2021-11-30 [2] CRAN (R 3.6.3) ## broom 0.8.0 2022-04-13 [2] CRAN (R 3.6.3) ## bslib 0.3.1 2021-10-06 [2] CRAN (R 3.6.3) ## cachem 1.0.6 2021-08-19 [2] CRAN (R 3.6.3) ## callr 3.7.0 2021-04-20 [2] CRAN (R 3.6.3) ## car 3.0-13 2022-05-02 [2] CRAN (R 3.6.3) ## carData 3.0-5 2022-01-06 [2] CRAN (R 3.6.3) ## caTools 1.18.2 2021-03-28 [2] CRAN (R 3.6.3) ## cellranger 1.1.0 2016-07-27 [2] CRAN (R 3.6.3) ## checkmate 2.1.0 2022-04-21 [2] CRAN (R 3.6.3) ## circlize * 0.4.15 2022-05-10 [2] CRAN (R 3.6.3) ## cli 3.3.0 2022-04-25 [2] CRAN (R 3.6.3) ## clue 0.3-61 2022-05-30 [2] CRAN (R 3.6.3) ## cluster 2.1.0 2019-06-19 [2] CRAN (R 3.6.3) ## codetools 0.2-16 2018-12-24 [2] CRAN (R 3.6.3) ## coin 1.4-2 2021-10-08 [2] CRAN (R 3.6.3) ## colorspace 2.0-3 2022-02-21 [2] CRAN (R 3.6.3) ## ComplexHeatmap * 2.2.0 2019-10-29 [2] Bioconductor ## cowplot * 1.1.1 2020-12-30 [2] CRAN (R 3.6.3) ## crayon 1.5.1 2022-03-26 [2] CRAN (R 3.6.3) ## crosstalk 1.2.0 2021-11-04 [2] CRAN (R 3.6.3) ## dada2 * 1.14.1 2020-02-22 [2] Bioconductor ## data.table * 1.14.2 2021-09-27 [2] CRAN (R 3.6.3) ## DBI 1.1.2 2021-12-20 [2] CRAN (R 3.6.3) ## dbplyr 2.1.1 2021-04-06 [2] CRAN (R 3.6.3) ## DelayedArray * 0.12.3 2020-04-09 [2] Bioconductor ## desc 1.4.1 2022-03-06 [2] CRAN (R 3.6.3) ## DESeq2 * 1.26.0 2019-10-29 [2] Bioconductor ## devtools 2.4.3 2021-11-30 [2] CRAN (R 3.6.3) ## digest 0.6.29 2021-12-01 [2] CRAN (R 3.6.3) ## doParallel 1.0.17 2022-02-07 [2] CRAN (R 3.6.3) ## dplyr * 1.0.9 2022-04-28 [2] CRAN (R 3.6.3) ## DT * 0.23 2022-05-10 [2] CRAN (R 3.6.3) ## dynamicTreeCut * 1.63-1 2016-03-11 [1] CRAN (R 3.6.3) ## edgeR 3.28.1 2020-02-26 [2] Bioconductor ## ellipsis 0.3.2 2021-04-29 [2] CRAN (R 3.6.3) ## EnhancedVolcano * 1.4.0 2019-10-29 [2] Bioconductor ## evaluate 0.15 2022-02-18 [2] CRAN (R 3.6.3) ## fansi 1.0.3 2022-03-24 [2] CRAN (R 3.6.3) ## farver 2.1.0 2021-02-28 [2] CRAN (R 3.6.3) ## fastcluster * 1.2.3 2021-05-24 [1] CRAN (R 3.6.3) ## fastmap 1.1.0 2021-01-25 [2] CRAN (R 3.6.3) ## fdrtool 1.2.17 2021-11-13 [2] CRAN (R 3.6.3) ## forcats * 0.5.1 2021-01-27 [2] CRAN (R 3.6.3) ## foreach 1.5.2 2022-02-02 [2] CRAN (R 3.6.3) ## foreign 0.8-75 2020-01-20 [2] CRAN (R 3.6.3) ## Formula 1.2-4 2020-10-16 [2] CRAN (R 3.6.3) ## fs 1.5.2 2021-12-08 [2] CRAN (R 3.6.3) ## genefilter 1.68.0 2019-10-29 [2] Bioconductor ## geneplotter 1.64.0 2019-10-29 [2] Bioconductor ## generics 0.1.2 2022-01-31 [2] CRAN (R 3.6.3) ## GenomeInfoDb * 1.22.1 2020-03-27 [2] Bioconductor ## GenomeInfoDbData 1.2.2 2020-08-24 [2] Bioconductor ## GenomicAlignments 1.22.1 2019-11-12 [2] Bioconductor ## GenomicRanges * 1.38.0 2019-10-29 [2] Bioconductor ## GetoptLong 1.0.5 2020-12-15 [2] CRAN (R 3.6.3) ## ggExtra * 0.10.0 2022-03-23 [2] CRAN (R 3.6.3) ## ggplot2 * 3.3.6 2022-05-03 [2] CRAN (R 3.6.3) ## ggpubr * 0.4.0 2020-06-27 [2] CRAN (R 3.6.3) ## ggrepel * 0.9.1 2021-01-15 [2] CRAN (R 3.6.3) ## ggsci * 2.9 2018-05-14 [2] CRAN (R 3.6.3) ## ggsignif 0.6.3 2021-09-09 [2] CRAN (R 3.6.3) ## glmnet 4.0 2020-05-14 [2] CRAN (R 3.6.3) ## GlobalOptions 0.1.2 2020-06-10 [2] CRAN (R 3.6.3) ## glue 1.6.2 2022-02-24 [2] CRAN (R 3.6.3) ## GO.db 3.10.0 2022-06-29 [1] Bioconductor ## gplots 3.1.3 2022-04-25 [2] CRAN (R 3.6.3) ## gridExtra 2.3 2017-09-09 [2] CRAN (R 3.6.3) ## gtable 0.3.0 2019-03-25 [2] CRAN (R 3.6.3) ## gtools 3.9.2.1 2022-05-23 [2] CRAN (R 3.6.3) ## haven 2.5.0 2022-04-15 [2] CRAN (R 3.6.3) ## highr 0.9 2021-04-16 [2] CRAN (R 3.6.3) ## Hmisc 4.7-0 2022-04-19 [2] CRAN (R 3.6.3) ## hms 1.1.1 2021-09-26 [2] CRAN (R 3.6.3) ## htmlTable 2.4.0 2022-01-04 [2] CRAN (R 3.6.3) ## htmltools 0.5.2 2021-08-25 [2] CRAN (R 3.6.3) ## htmlwidgets 1.5.4 2021-09-08 [2] CRAN (R 3.6.3) ## httpuv 1.6.5 2022-01-05 [2] CRAN (R 3.6.3) ## httr 1.4.3 2022-05-04 [2] CRAN (R 3.6.3) ## hwriter 1.3.2.1 2022-04-08 [2] CRAN (R 3.6.3) ## igraph * 1.3.1 2022-04-20 [2] CRAN (R 3.6.3) ## IHW 1.14.0 2019-10-29 [2] Bioconductor ## impute 1.60.0 2019-10-29 [2] Bioconductor ## IRanges * 2.20.2 2020-01-13 [2] Bioconductor ## iterators 1.0.14 2022-02-05 [2] CRAN (R 3.6.3) ## jpeg 0.1-9 2021-07-24 [2] CRAN (R 3.6.3) ## jquerylib 0.1.4 2021-04-26 [2] CRAN (R 3.6.3) ## jsonlite 1.8.0 2022-02-22 [2] CRAN (R 3.6.3) ## KernSmooth 2.23-16 2019-10-15 [2] CRAN (R 3.6.3) ## knitr 1.39 2022-04-26 [2] CRAN (R 3.6.3) ## labeling 0.4.2 2020-10-20 [2] CRAN (R 3.6.3) ## later 1.3.0 2021-08-18 [2] CRAN (R 3.6.3) ## lattice * 0.20-38 2018-11-04 [2] CRAN (R 3.6.3) ## latticeExtra 0.6-29 2019-12-19 [2] CRAN (R 3.6.3) ## lazyeval 0.2.2 2019-03-15 [2] CRAN (R 3.6.3) ## libcoin 1.0-9 2021-09-27 [2] CRAN (R 3.6.3) ## lifecycle 1.0.1 2021-09-24 [2] CRAN (R 3.6.3) ## limma 3.42.2 2020-02-03 [2] Bioconductor ## locfit 1.5-9.4 2020-03-25 [2] CRAN (R 3.6.3) ## lpsymphony 1.14.0 2019-10-29 [2] Bioconductor (R 3.6.3) ## lubridate 1.8.0 2021-10-07 [2] CRAN (R 3.6.3) ## magrittr 2.0.3 2022-03-30 [2] CRAN (R 3.6.3) ## MASS 7.3-51.5 2019-12-20 [2] CRAN (R 3.6.3) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 3.6.3) ## matrixStats * 0.62.0 2022-04-19 [2] CRAN (R 3.6.3) ## memoise 2.0.1 2021-11-26 [2] CRAN (R 3.6.3) ## metagenomeSeq 1.28.2 2020-02-03 [2] Bioconductor ## mgcv 1.8-31 2019-11-09 [2] CRAN (R 3.6.3) ## mime 0.12 2021-09-28 [2] CRAN (R 3.6.3) ## miniUI 0.1.1.1 2018-05-18 [2] CRAN (R 3.6.3) ## modelr 0.1.8 2020-05-19 [2] CRAN (R 3.6.3) ## modeltools 0.2-23 2020-03-05 [2] CRAN (R 3.6.3) ## multcomp 1.4-19 2022-04-26 [2] CRAN (R 3.6.3) ## multtest 2.42.0 2019-10-29 [2] Bioconductor ## munsell 0.5.0 2018-06-12 [2] CRAN (R 3.6.3) ## mvtnorm 1.1-3 2021-10-08 [2] CRAN (R 3.6.3) ## nlme 3.1-144 2020-02-06 [2] CRAN (R 3.6.3) ## nnet 7.3-12 2016-02-02 [2] CRAN (R 3.6.3) ## permute * 0.9-7 2022-01-27 [2] CRAN (R 3.6.3) ## pheatmap 1.0.12 2019-01-04 [2] CRAN (R 3.6.3) ## phyloseq * 1.30.0 2019-10-29 [2] Bioconductor ## pillar 1.7.0 2022-02-01 [2] CRAN (R 3.6.3) ## pkgbuild 1.3.1 2021-12-20 [2] CRAN (R 3.6.3) ## pkgconfig 2.0.3 2019-09-22 [2] CRAN (R 3.6.3) ## pkgload 1.2.4 2021-11-30 [2] CRAN (R 3.6.3) ## plotly * 4.10.0 2021-10-09 [2] CRAN (R 3.6.3) ## plyr 1.8.7 2022-03-24 [2] CRAN (R 3.6.3) ## png 0.1-7 2013-12-03 [2] CRAN (R 3.6.3) ## preprocessCore 1.48.0 2019-10-29 [2] Bioconductor ## prettyunits 1.1.1 2020-01-24 [2] CRAN (R 3.6.3) ## processx 3.5.3 2022-03-25 [2] CRAN (R 3.6.3) ## promises 1.2.0.1 2021-02-11 [2] CRAN (R 3.6.3) ## ps 1.7.0 2022-04-23 [2] CRAN (R 3.6.3) ## purrr * 0.3.4 2020-04-17 [2] CRAN (R 3.6.3) ## R6 2.5.1 2021-08-19 [2] CRAN (R 3.6.3) ## RColorBrewer * 1.1-3 2022-04-03 [2] CRAN (R 3.6.3) ## Rcpp * 1.0.8.3 2022-03-17 [2] CRAN (R 3.6.3) ## RcppParallel 5.1.5 2022-01-05 [2] CRAN (R 3.6.3) ## RCurl 1.98-1.6 2022-02-08 [2] CRAN (R 3.6.3) ## readr * 2.1.2 2022-01-30 [2] CRAN (R 3.6.3) ## readxl * 1.4.0 2022-03-28 [2] CRAN (R 3.6.3) ## remotes 2.4.2 2021-11-30 [2] CRAN (R 3.6.3) ## reprex 2.0.1 2021-08-05 [2] CRAN (R 3.6.3) ## reshape2 1.4.4 2020-04-09 [2] CRAN (R 3.6.3) ## rhdf5 2.30.1 2019-11-26 [2] Bioconductor ## Rhdf5lib 1.8.0 2019-10-29 [2] Bioconductor ## rJava 1.0-6 2021-12-10 [1] CRAN (R 3.6.3) ## rjson 0.2.20 2018-06-08 [2] CRAN (R 3.6.3) ## rlang 1.0.2 2022-03-04 [2] CRAN (R 3.6.3) ## rmarkdown 2.14 2022-04-25 [2] CRAN (R 3.6.3) ## rpart 4.1-15 2019-04-12 [2] CRAN (R 3.6.3) ## rprojroot 2.0.3 2022-04-02 [2] CRAN (R 3.6.3) ## Rsamtools 2.2.3 2020-02-23 [2] Bioconductor ## RSQLite 2.2.14 2022-05-07 [2] CRAN (R 3.6.3) ## rstatix 0.7.0 2021-02-13 [2] CRAN (R 3.6.3) ## rstudioapi 0.13 2020-11-12 [2] CRAN (R 3.6.3) ## rvest 1.0.2 2021-10-16 [2] CRAN (R 3.6.3) ## S4Vectors * 0.24.4 2020-04-09 [2] Bioconductor ## sandwich 3.0-1 2021-05-18 [2] CRAN (R 3.6.3) ## sass 0.4.1 2022-03-23 [2] CRAN (R 3.6.3) ## scales 1.2.0 2022-04-13 [2] CRAN (R 3.6.3) ## seqinr * 4.2-16 2022-05-19 [2] CRAN (R 3.6.3) ## sessioninfo 1.2.2 2021-12-06 [2] CRAN (R 3.6.3) ## shape 1.4.6 2021-05-19 [2] CRAN (R 3.6.3) ## P shiny 1.7.1 2021-10-02 [2] CRAN (R 3.6.3) ## ShortRead 1.44.3 2020-02-03 [2] Bioconductor ## slam 0.1-50 2022-01-08 [2] CRAN (R 3.6.3) ## stringi 1.7.6 2021-11-29 [2] CRAN (R 3.6.3) ## stringr * 1.4.0 2019-02-10 [2] CRAN (R 3.6.3) ## SummarizedExperiment * 1.16.1 2019-12-19 [2] Bioconductor ## survival 3.1-8 2019-12-03 [2] CRAN (R 3.6.3) ## testthat 3.1.4 2022-04-26 [2] CRAN (R 3.6.3) ## TH.data 1.1-1 2022-04-26 [2] CRAN (R 3.6.3) ## tibble * 3.1.7 2022-05-03 [2] CRAN (R 3.6.3) ## tidyr * 1.2.0 2022-02-01 [2] CRAN (R 3.6.3) ## tidyselect 1.1.2 2022-02-21 [2] CRAN (R 3.6.3) ## tidyverse * 1.3.1.9000 2021-11-19 [2] Github (tidyverse/tidyverse@663456e) ## tzdb 0.3.0 2022-03-28 [2] CRAN (R 3.6.3) ## usethis 2.1.6 2022-05-25 [2] CRAN (R 3.6.3) ## utf8 1.2.2 2021-07-24 [2] CRAN (R 3.6.3) ## vctrs 0.4.1 2022-04-13 [2] CRAN (R 3.6.3) ## vegan * 2.6-2 2022-04-17 [2] CRAN (R 3.6.3) ## viridisLite 0.4.0 2021-04-13 [2] CRAN (R 3.6.3) ## WGCNA * 1.71 2022-04-22 [1] CRAN (R 3.6.3) ## withr 2.5.0 2022-03-03 [2] CRAN (R 3.6.3) ## Wrench 1.4.0 2019-10-29 [2] Bioconductor ## xfun 0.31 2022-05-10 [2] CRAN (R 3.6.3) ## xlsx * 0.6.5 2020-11-10 [1] CRAN (R 3.6.3) ## xlsxjars 0.6.1 2014-08-22 [1] CRAN (R 3.6.3) ## XMAS2 * 2.1.5 2022-07-05 [2] local ## XML 3.99-0.3 2020-01-20 [2] CRAN (R 3.6.3) ## xml2 1.3.3 2021-11-30 [2] CRAN (R 3.6.3) ## xtable 1.8-4 2019-04-21 [2] CRAN (R 3.6.3) ## XVector 0.26.0 2019-10-29 [2] Bioconductor ## xviz * 1.1.0 2021-04-15 [2] local ## yaml 2.3.5 2022-02-21 [2] CRAN (R 3.6.3) ## zlibbioc 1.32.0 2019-10-29 [2] Bioconductor ## zoo 1.8-10 2022-04-15 [2] CRAN (R 3.6.3) ## ## [1] /share/home/zouhua/R/x86_64-pc-linux-gnu-library/3.6 ## [2] /opt/R-3.6.3/lib/R/library ## ## P ── Loaded and on-disk path mismatch. ## ## ─────────────────────────────────────────────────────────────────────────────────────────────────── "],["halla-tutorial.html", "Chapter 3 Halla tutorial 3.1 Introduction 3.2 HAllA 步骤 3.3 结果展示", " Chapter 3 Halla tutorial 3.1 Introduction HAllA (Hierarchical All-against-All association) 是一个针对多维度、异质型数据集的多重关联分析工具。可用于连续型/分类型数值数据，且在同质型（homogeneous）数据集（所有数值皆相同类型，例如：RNA-seq 基因表現）与异质型（heterogeneous）数据集（不同单位或类型的数值，例如：病患临床指标）皆可高效分析。在目前微生物研究中，HAllA是一個常用于微生物组-代谢、微生物组-临床指标、微生物组-转录组（基因表現、miRNA、GO） 等关联分析的重要工具。 HAllA source 3.2 HAllA 步骤 3.2.1 登102集群: 执行下述步骤 conda activate /opt/conda/envs/Halla halla -h halla -x table_X -y table_Y -m correlation_methods -o output_file --fdr_alpha adjustP --fdr_method FDR_methods HAllA workflow 3.2.2 Available pairwise distance metrics: spearman (default for continuous data) pearson mi (A set of properties of Mutual Information result from definition. default for mixed/categorical data) nmi (Normalized Mutual Information) xicor (Chatterjee correlation, uses rank differences to assess the degree to which one variable is a measurable function of another，适用于离散、非线性关系数据) dcor (measures not necessarily linear dependency of two random variables with possibly different dimensions) HAllA correlation methods 3.2.3 Running procedures step1 The pairwise similarity matrix between all features in X and Y is computed with a specified similarity measure, such as Spearman correlation and normalized mutual information (NMI). This step then generates the p-value and q-value tables. Note that for handling heterogeneous data, all continuous features are first discretized into bins using a specified binning method. step2 Hierarchical clustering on the features in each dataset is performed using the converted similarity measure used in step 1. It produces a tree for each dataset. step3 Finding densely-associated blocks(pseudocode): def find_densely_associated_blocks(x, y): x_features = all features in x y_features = all features in y if is_densely_associated(x_features, y_features): report block and terminate else: # bifurcate one according to Gini impurities of the splits x_branches, y_branches = bifurcate_one_of(x, y) if both x and y are leaves: terminate for each x_branch and y_branch in x_branches and y_branches: find_densely_associated_blocks(x_branch, y_branch) initial function call: find_densely_associated_blocks(X_root, Y_root) For example, given two datasets of X (features: X1, X2, X3, X4, X5) and Y (features: Y1, Y2, Y3, Y4) both hierarchically clustered in X tree and Y tree, the algorithm first evaluates the roots of both trees and checks if the block consisting of all features of X and Y are densely-associated (if %significance (%reject) &gt;= (1 - FNR)%). If the block is not densely-associated, the algorithm would bifurcate one of the trees. It would pick one of: ·[X1 X2][X3 X4 X5] &gt;&lt; [Y1 Y2 Y3 Y4] or ·[X1 X2 X3 X4 X5] &gt;&lt; [Y1 Y2 Y3][Y4] based on the Gini impurity of the splits (pick the split that produces a lower weighted Gini impurity), Once it picks the split with the lower impurity (let’s say the first split), it will iteratively evaluate the branches: ·find densely-associated blocks in [X1 X2] vs [Y1 Y2 Y3 Y4], and ·find densely-associated blocks in [X3 X4 X5] vs [Y1 Y2 Y3 Y4] and keep going until it terminates. 3.3 结果展示 Correlation with modules 此部分分析用的wgcna生成的宏基因组和代谢组 modules，因此在运行halla的时候需要加上 —alla 取消数据集内部cluster构建。 Correlation with modules 此部分分析用的GvHD的宏基因组和代谢组的原始数据（spearman-correlation），热图中显著性的cluster均有数字或白点进行标注（过滤条件fdr &lt; 0.05）；其中的数值显示是按照cluster 中最小的 adjust p-value 给定rank，序号越小，显著性越强。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
