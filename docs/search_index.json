[["index.html", "Omics analysis Chapter 1 Omics Analysis 1.1 Introducution to WGCNA 1.2 Introducution to HAllA 1.3 Introducution to NetCoMi", " Omics analysis Zhengnong Zhu, Yifan Zhao, Hua Zou, Bangzhuo Tong 2022-09-15 Chapter 1 Omics Analysis 多组学整合分析随着高通量技术的广泛应用而生，研究人员可以从基因组、转录组、蛋白质组、交互组、表观基因组、代谢组、脂质体和微生物组等不同分子层面大规模获取组学数据，多组学整合数据分析使得生物学发生了革命性的变化，促进我们对生物过程和分子机制的深刻理解。单一组学分析方法可以提供不同生命进程或者疾病组与正常组相比差异的生物学过程的信息。但是，这些分析往往有局限性。多组学方法整合几个组学水平的信息，为生物机制提供了更多证据，从深层次挖掘候选关键因子；通过将各种组学，不同层面之间信息进行整合，构建基因调控网络，深层次理解各个分子之间的调控及因果关系，从而更深入的认识生物进程和疾病过程中复杂性状的分子机理和遗传基础。 公司常见组学数据类型：微生物组（宏基因组/16S），代谢组，转录组，临床/表型数据等。 Three tools would be introduced in this book: WGCNA HAllA NetCoMi And the details of the tools are given below. 1.1 Introducution to WGCNA The WGCNA R software package is a comprehensive collection of R functions for performing various aspects of weighted correlation network analysis. The package includes functions for network construction, module detection, gene selection, calculations of topological properties, data simulation, visualization, and interfacing with external software. Along with the R package we also present R software tutorials. While the methods development was motivated by gene expression data, the underlying data mining approach can be applied to a variety of different settings. WGCNA workflow 7 steps are included in WGCNA (Detailed in Chapter1): The Definition of a Gene Co-expression Similarity The Definition of a Family of Adjacency Functions Determining the Parameters of the Adjacency Function Defining a Measure of Node Dissimilarity Identifying Gene Modules Relating Network Concepts to Each Other In the WGCNA chapter, two demo data were used: 16S data from SLE project (45 samples with 1364 ASVs) MGS and metabolic data from GvHD project (32 samples with 250 species features and 811 metabolite features) 1.2 Introducution to HAllA HAllA (Hierarchical All-against-All association) 是一个针对多维度、异质型数据集的多重关联分析工具。可用于连续型/分类型数值数据，且在同质型（homogeneous）数据集（所有数值皆相同类型，例如：RNA-seq 基因表現）与异质型（heterogeneous）数据集（不同单位或类型的数值，例如：病患临床指标）皆可高效分析。在目前微生物研究中，HAllA是一個常用于微生物组-代谢、微生物组-临床指标、微生物组-转录组（基因表現、miRNA、GO） 等关联分析的重要工具。 HAllA workflow Note: Users can use output from WGCNA as input for HALLA. 1.3 Introducution to NetCoMi Estimating microbial association networks from high-throughput sequencing data is a common exploratory data analysis approach aiming at understanding the complex interplay of microbial communities in their natural habitat. Statistical network estimation workflows comprise several analysis steps, including methods for zero handling, data normalization and computing microbial associations. Since microbial interactions are likely to change between conditions, e.g. between healthy individuals and patients, identifying network differences between groups is often an integral secondary analysis step. NetCoMi workflow "],["wgcna.html", "Chapter 2 WGCNA 2.1 Introduction 2.2 Environment Setup 2.3 WGCNA for 16S data 2.4 WGCNA for MGS data 2.5 WGCNA for metabolic data 2.6 Metabolites, mgs and metadata association 2.7 Session Info", " Chapter 2 WGCNA For any questions about this chapter, please contact zhuzhengnong (zhuzhengnong@xbiome.com) 2.1 Introduction In this book, we will introduce an method of multi-omics association analysis, entitled WGCNA. We will introduce usage and principle of WGCNA. Moreover, we will utilize GVHD data to illustate pipelines of WGCNA. Correlation networks are increasingly being used in bioinformatics applications. For example, weighted gene co-expression network analysis is a systems biology method for describing the correlation patterns among genes across microarray samples. Weighted correlation network analysis (WGCNA) can be used for finding clusters (modules) of highly correlated genes, for summarizing such clusters using the module eigengene or an intramodular hub gene, for relating modules to one another and to external sample traits (using eigengene network methodology), and for calculating module membership measures. Correlation networks facilitate network based gene screening methods that can be used to identify candidate biomarkers or therapeutic targets. These methods have been successfully applied in various biological contexts, e.g. cancer, mouse genetics, yeast genetics, and analysis of brain imaging data. While parts of the correlation network methodology have been described in separate publications, there is a need to provide a user-friendly, comprehensive, and consistent software implementation and an accompanying tutorial. The WGCNA R software package is a comprehensive collection of R functions for performing various aspects of weighted correlation network analysis. The package includes functions for network construction, module detection, gene selection, calculations of topological properties, data simulation, visualization, and interfacing with external software. Along with the R package we also present R software tutorials. While the methods development was motivated by gene expression data, the underlying data mining approach can be applied to a variety of different settings. More details can be found on WGCNA website WGCNA workflow 2.1.1 Introduction to the 7 Steps in WGCNA Please read the follwing introduction to the steps of WGCNA. If you know WGCNA very well, please jump to Environment Setup 2.1.1.1 Step one: The Definition of a Gene Co-expression Similarity 第一步首先确定需要构建网络模块使用那种 correlation 方法去计算节点之间的相关性，常见的方法为 Pearson correlation \\(s_{ij} = |cor(i,j)|\\)，那么 similarity matrix \\(S = [s_{ij}]\\)。当然，我们可以根据不同的数据使用不同的correlation算法。WGCNA默认的correlation算法为bicor 2.1.1.2 Step two: The Definition of a Family of Adjacency Functions 第二步是确定邻接矩阵。将similarity matrix 转化为 adjacency matrix，需要一个阈值。确定这个阈值有两种方法，hard threshold 和 soft threshold。 hard threshold 通常使用signum函数作为连接函数来实现： \\[ a_{ij} = signum(s_{ij}, \\tau) \\equiv \\begin{cases} 1 \\quad if s_{ij} \\geq \\tau \\\\ 0 \\quad if s_{ij} \\le \\tau \\end{cases} \\] Hard threshoding using the signum function leads to intuitive network concepts, but it may lead to a loss of information: if \\(\\tau\\) has been set to 0.8, there will be no connection between two nodes if their similarity equals 0.79. To avoid the disadvantage of hard thresholding, we propose two types of ‘soft’ adjacency functions: the sigmoid function \\[ a_{ij} = sigmoid(s_{ij}, \\alpha, \\tau_{0}) \\equiv \\frac{1}{1+e^{-\\alpha(s_{ij}-\\tau_{0})}} \\] the power adjacency function \\[ a_{ij} = power(s_{ij}, \\beta) \\equiv |s_{ij}|^\\beta \\] 根据不同adjacency function构建的不同adjacency matrix a图为使用sigmoid function的adjacency matrix，b图为使用power function的adjacency matrix。从图中我们可以看出power function的adjacency matrix能够保留大部分强相关连的关系，弱关联的关系则会被消除，能够减少节点之间的连接噪音。在我们的WGCNA流程中我们默认选择的是power function方法去构建adjacency。 2.1.1.3 Step three: Determining the Parameters of the Adjacency Function 第三步是确定adjacency function的参数，对我们的流程来说，就是确定 \\(\\beta\\) 参数。为了确定参数，WGCNA提出了无标度拓扑网络（The Scale-free Topology）的概念。无标度网络在pathways, metabolic等生物数据上已经得到了验证，因此我们也假设基因的表达，微生物的生长关系也是符合无标度拓扑网络的概念。因此，当选择的参数需要满足无标度拓扑网络的构建。 什么是无标度网络？ scale-free topology 无标度网络的形象描述就是，有一个hub node，大部分的节点与其相连接，而这些节点本身连接较少。 怎么判断合适的 \\(\\beta\\)? Earlier, we have described that he linear regression model fitting index \\(R^2\\) can be used to quantify how well a network satisfies a scale-free topology. There is a natural trade-off between maximizing scale-free topology model fit(\\(R^2\\)) and maintaining a high mean number of connections: parameter values that lead to an \\(R^2\\) value close to 1 may lead to networks with very few connections. select beta 如上图所示，当\\(\\beta\\)为6时，\\(R^2\\)接近与1，但是任然保留较高的connections 2.1.1.4 Step four: Defining a Measure of Node Dissimilarity 第四步确定节点之间的不相似性距离。通过构建node之间的dissimilarity，然后用cluster方法可以将node（gene or others）划分到不同的module，同时也可以观察一个module中的node的连接紧密程度。 The topology overlap matrix (TOM) \\(\\Omega = [w_{ij}]\\) \\[ w_{ij} = \\frac{l_{ij} + a_{ij}}{min\\{k_{i}, k_{j}\\} + 1 - a_{ij}} \\] \\(l_{ij} = \\sum_{u}a_{iu}a_{uj}\\), 表示i和j共享连接的u之间的关系乘的和 \\(k_{i} = \\sum_{j=1}^na_{ij}\\),表示i的所有连接和 dissimilarity measure is defined by \\(d_{ij}^w = 1 - w_{ij}\\) 2.1.1.5 Step five: Identifying Gene Modules 第5步划分module。根据\\(d_{ij}^w\\), 用cluster方法划分module split modules a height cutoff value is chosen in the dendrogram such that some of the resulting branches correspond to dark squares(modules) along the diagonal of the TOM plot. 2.1.1.6 Step six: Relating Network Concepts to Each Other 第六步定义模块中的属性。 比如hub node。Each module can be represented by a centroid, e.g., an intramodular hub gene. Singular value decomposition \\[ X^{(q)} = [x_{ij}^{(q)}] = (x_{1}^{(q)} \\quad x_{2}^{(q)} \\quad x_{3}^{(q)} \\dots x_{n}^{(q)})^T \\\\ X^{(q)} = U^{(q)}D^{(q)}(V^{(q)})^T \\\\ V^{(q)} = (v_{1}^{(q)} \\quad v_{2}^{(q)} \\quad v_{3}^{(q)} \\dots v_{m}^{(q)}) \\] Module Eigengene: \\[ E^{(q)} = v_{1}^{(q)} \\] 2. module之间的correlation，如果两个module的correlation很高，可以合并两个module为一个。 2.1.1.7 Step seven: Relating Network Concepts to External Gene or Sample Information 第七步，将module与外部数据相关联，找到感兴趣的module。 A main purpose of many network analysis is to relate a connectivity measure to external gene information. For example, In our cancer microarray application, we show that for brown module genes intramodular connectivity is highly correlated with prognostic significance for cancer surival. relating to external information 如上图所示，临床数据（weight）与brown module最相关，表示这个module中的gene or node对weight有显著性的影响。 Users can choose different chapters to read according to their own data type: 16S, MGS and metabolic data. You can also [integrate the modules from different data type into a network. 2.2 Environment Setup Seek help from Zhuzhengnong(zhuzhengnong@xbiome.com) on any issues about the installation of R packages/dependencies in this tutorial. library(tidyverse) library(xlsx) library(WGCNA) library(igraph) library(phyloseq) library(DT) options(stringsAsFactors = FALSE) 2.3 WGCNA for 16S data Data used in this sub-chapter belongs to SLE project, including 45 samples with 1364 ASVs. 2.3.1 Data loading (WGCNA 16S) 2.3.1.1 Read counts table from rds seq_tab &lt;- readRDS(&quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/SLE/data/dada2_res.rds&quot;)$seq_tab # 将ASV替换为ASV1，ASV2，... ASV_index &lt;- data.frame(ASV=colnames(seq_tab)) ASV_index$index &lt;- paste0(&quot;ASV&quot;,c(1:dim(ASV_index)[1])) colnames(seq_tab) &lt;- ASV_index$index datatable(seq_tab[1:10, 1:10]) 2.3.1.2 Read taxa table from rds taxa_tb &lt;- readRDS(&quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/SLE/data/dada2_res.rds&quot;)$tax_tab taxa_tb &lt;- merge(ASV_index, taxa_tb, by.x = &quot;ASV&quot;, by.y = 0) taxa_tb &lt;- taxa_tb[,-c(1)] # remove ASV column taxa_tb &lt;- taxa_tb %&gt;% column_to_rownames(&quot;index&quot;) datatable(taxa_tb[1:5, ]) 2.3.1.3 Remove low count-number ASVs (count number &lt; 500) dim(seq_tab) ## [1] 45 1364 seq_tab_filter &lt;- seq_tab %&gt;% .[, apply(.&gt;500, 2, any)] dim(seq_tab_filter) ## [1] 45 231 taxa_tb &lt;- taxa_tb[colnames(seq_tab_filter),] dim(taxa_tb) ## [1] 231 7 2.3.2 Build WGCNA network (WGCNA 16S) 2.3.2.1 Set parameters (WGCNA 16S) # Set seed as a precaution for reproducibility as some methods are non-deterministic. set.seed(13118) Run_analysis &lt;- TRUE # if FALSE it tries to load data instead of running save_plots &lt;- TRUE plot_labeling_size = 15 prefix &lt;- &quot;m&quot; save_TOM &lt;- TRUE pam_stage &lt;- FALSE # Partitioning around medoids, tries to put more OTUs into modules where it is not directly clear from the dendrogram cutting. set_verbose = 1 # How much detail from the WGCNA functions? Higher means more detail. parameter_sets &lt;- list(set_1 = list(applied_norm = &quot;TSS&quot;, applied_transf = &quot;CLR&quot;, assoc_measure = &quot;bicor&quot;), set_2 = list(applied_norm = &quot;CSS&quot;, applied_transf = &quot;log2&quot;, assoc_measure = &quot;bicor&quot;)) chosen_parameter_set &lt;- parameter_sets$set_2 pcCorrection &lt;- F if(pcCorrection){ estimate_n.pc = F if(!estimate_n.pc){ number_of_pcs_to_remove = 0 # Does not matter when pcCorrection is FALSE } } save_name &lt;- &quot;16S_network_module&quot; 2.3.2.2 Data normalization (WGCNA 16S) if(chosen_parameter_set$applied_norm == &quot;TSS&quot;){ # Normalize seq_tab_filter &lt;- apply(seq_tab_filter, MARGIN = 2, function(x){x/sum(x) * 100}) seq_tab_filter &lt;- propr:::proprCLR(t(seq_tab_filter) + 1) # t(), samples as rows, variables as columns seq_tab_filter &lt;- t(seq_tab_filter) } if(chosen_parameter_set$applied_norm == &quot;CSS&quot;){ # Normalization and transformation in one data.metagenomeSeq &lt;- metagenomeSeq::newMRexperiment(seq_tab_filter) # Variables as rows, samples as columns p &lt;- metagenomeSeq::cumNormStat(data.metagenomeSeq) data.cumnorm &lt;- metagenomeSeq::cumNorm(data.metagenomeSeq, p=p) seq_tab_filter &lt;- metagenomeSeq::MRcounts(data.cumnorm, norm=TRUE, log=TRUE) # log here is a +1 shifted log2 } ## Default value being used. seq_tab_filter &lt;- seq_tab_filter dim(seq_tab_filter) %&gt;% paste(c(&quot;Samples&quot;, &quot;OTUs&quot;)) ## [1] &quot;45 Samples&quot; &quot;231 OTUs&quot; 2.3.2.3 Select the best power parameter for Soft threshold Before running this chunk and the the chunks onwards, please make sure that your data has been filtered and normalized. Also make sure that samples are on row and features are on column in your input profile table powers &lt;- c(1:10, seq(12,20,2)) suppressWarnings(sft &lt;- pickSoftThreshold(seq_tab_filter, powerVector = powers, verbose = set_verbose, networkType = &quot;signed&quot;, corFn= chosen_parameter_set$assoc_measure)) ## pickSoftThreshold: will use block size 231. ## pickSoftThreshold: calculating connectivity for given powers... \b..0% \b\b\b\b\b..100% ## Power SFT.R.sq slope truncated.R.sq mean.k. median.k. max.k. ## 1 1 0.6140 11.20 0.9500 118.000 119.0000 129.00 ## 2 2 0.0977 1.59 0.8770 63.000 62.8000 76.10 ## 3 3 0.1530 -1.20 0.7990 34.800 34.2000 46.90 ## 4 4 0.2970 -1.44 0.8540 19.900 19.2000 30.00 ## 5 5 0.2820 -1.17 0.8240 11.900 11.3000 19.70 ## 6 6 0.3040 -1.02 0.9330 7.370 7.0000 13.70 ## 7 7 0.3360 -1.00 0.9280 4.760 4.4200 9.77 ## 8 8 0.4560 -1.09 0.8500 3.210 2.8400 7.18 ## 9 9 0.5630 -1.07 0.7710 2.250 1.9100 5.49 ## 10 10 0.7380 -1.33 0.8710 1.640 1.3400 4.85 ## 11 12 0.1900 -3.14 -0.0251 0.977 0.6970 4.12 ## 12 14 0.1970 -2.85 -0.0237 0.663 0.3710 3.73 ## 13 16 0.2850 -4.10 0.1900 0.499 0.2150 3.50 ## 14 18 0.2450 -4.12 0.0383 0.407 0.1220 3.36 ## 15 20 0.2480 -3.81 0.0410 0.351 0.0795 3.26 # Find the soft thresholding power beta to which co-expression similarity is raised to calculate adjacency. # based on the criterion of approximate scale-free topology. idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.90)) if(is.infinite(idx)){ idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.80)) if(!is.infinite(idx)){ st &lt;- sft$fitIndices[idx,1] } else{ idx &lt;- which.max(-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) st &lt;- sft$fitIndices[idx,1] } } else{ st &lt;- sft$fitIndices[idx,1] } # Plot Scale independence measure and Mean connectivity measure # Scale-free topology fit index as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], sfApprox = -sign(sft$fitIndices[,3])*sft$fitIndices[,2]) %&gt;% ggplot() + geom_hline(yintercept = 0.9, color = &quot;red&quot;, alpha = 0.6) + # corresponds to R^2 cut-off of 0.9 geom_hline(yintercept = 0.8, color = &quot;red&quot;, alpha = 0.2) + # corresponds to R^2 cut-off of 0.8 geom_line(aes(x = Indices, y = sfApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = sfApprox, label = Indices), color = &quot;red&quot;, size = 4) + ggtitle(&quot;Scale independence&quot;) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;SF Model Fit,signed R^2&quot;) + xlim(1,20) + ylim(-1,1) + geom_segment(aes(x = st, y = 0.25, xend = st, yend = sfApprox[idx]-0.05), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.5)-&gt; scale_independence_plot # Mean connectivity as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], meanApprox = sft$fitIndices[,5]) %&gt;% ggplot() + geom_line(aes(x = Indices, y = meanApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = meanApprox, label = Indices), color = &quot;red&quot;, size = 4) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;Mean Connectivity&quot;) + geom_segment(aes(x = st-0.4, y = sft$fitIndices$mean.k.[idx], xend = 0, yend = sft$fitIndices$mean.k.[idx]), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.4) + ggtitle(paste0(&quot;Mean connectivity: &quot;, round(sft$fitIndices$mean.k.[idx],2))) -&gt; mean_connectivity_plot cowplot::plot_grid(scale_independence_plot, mean_connectivity_plot, ncol = 2, align = &quot;h&quot;, labels = c(&quot;A&quot;, &quot;B&quot;), label_size = plot_labeling_size) -&gt; si_mc_plot si_mc_plot 2.3.3 Block-wise network construction and module detection The function blockwiseModules will first pre cluster with fast crude clustering method to cluster OTUs into blocks not exceeding the maximum, blocks may therefore not be fully optimal in the end. Adjust the parameters to fit your own data. Run_analysis &lt;- TRUE if(Run_analysis){ modules.otu &lt;- blockwiseModules(seq_tab_filter, power = st, networkType = &quot;signed&quot;, TOMType = &quot;signed&quot;, corType = chosen_parameter_set$assoc_measure, maxPOutliers = 0.05, deepSplit = 2, pamStage = pam_stage, pamRespectsDendro = TRUE, mergeCutHeight = 0.25, replaceMissingAdjacencies = TRUE, minModuleSize = 5, # There are fewer otus than genes, and that many might not be connected numericLabels = TRUE, saveTOMs = save_TOM, saveTOMFileBase = paste0(&quot;/share/projects/Analytics/analytics/MultiOmics/tools/Bookdown/result/&quot;, save_name), verbose = set_verbose) rownames(modules.otu$MEs) &lt;- rownames(seq_tab_filter) names(modules.otu$colors) &lt;- colnames(seq_tab_filter) names(modules.otu$unmergedColors) &lt;- colnames(seq_tab_filter) hubs &lt;- chooseTopHubInEachModule(seq_tab_filter, modules.otu$colors) } ## Calculating module eigengenes block-wise from all genes 2.3.3.1 Visualizing module characteristics # Convert labels to colors for plotting merged_colors &lt;- labels2colors(modules.otu$colors) n_modules &lt;- unique(merged_colors) %&gt;% length() samples_good &lt;- sum(modules.otu$goodSamples) == length(modules.otu$goodSamples) OTUs_good &lt;- sum(modules.otu$goodGenes) == length(modules.otu$goodGenes) ME_good &lt;- sum(modules.otu$MEsOK) == length(modules.otu$MEsOK) 2.3.3.2 Display OTUs in each module table(modules.otu$colors) %&gt;% as.data.frame() %&gt;% dplyr::rename(Module = Var1, Size = Freq) %&gt;% dplyr::mutate(Module_color = labels2colors(as.numeric(as.character(Module)))) -&gt; module_size module_size %&gt;% ggplot(aes(x = Module, y = Size, fill = Module)) + geom_col(color = &quot;#000000&quot;) + ggtitle(&quot;Number of OTUs in each module&quot;) + theme(legend.position = &quot;none&quot;) + scale_fill_manual(values = setNames(module_size$Module_color,module_size$Module)) + geom_text(aes(label = Size),vjust = 0.5, hjust = -0.18, size = 3.5) + ylim(0, max(module_size$Size)*1.1) + theme(plot.margin = margin(2, 2, 2, 2, &quot;pt&quot;)) + coord_flip()-&gt; module_size_barplot module_size_barplot 2.3.3.3 Extract modules in the network plotEigengeneNetworks(modules.otu$MEs, &quot;Eigengene adjacency heatmap&quot;, marDendro = c(3,3,2,4), marHeatmap = c(3,4,2,2), plotDendrograms = T, xLabelsAngle = 90) ## Show module info table(modules.otu$colors) %&gt;% as.data.frame() -&gt; res res$`Module color` &lt;- WGCNA::labels2colors(as.numeric(as.character(res$Var1))) res &lt;- res[, c(1,3,2)] colnames(res) &lt;- c(&quot;Module&quot;, &quot;Module color&quot;, &quot;Number of OTUs&quot;) print(res) ## Module Module color Number of OTUs ## 1 0 grey 141 ## 2 1 turquoise 58 ## 3 2 blue 10 ## 4 3 brown 8 ## 5 4 yellow 8 ## 6 5 green 6 2.3.3.4 Dendrogram of modules # Plot the dendrogram and the module colors underneath for each block for(i in seq_along(modules.otu$dendrograms)){ plotDendroAndColors(modules.otu$dendrograms[[i]], merged_colors[modules.otu$blockGenes[[i]]], &quot;Module colors&quot;, dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = paste0(&quot;Cluster Dendrogram\\n&quot;, &quot;for block &quot;, i,&quot;: &quot;, length(modules.otu$blockGenes[[i]]), &quot; OTUs&quot;)) } 2.3.4 Module (Eigengene) correlation MEs &lt;- modules.otu$MEs # Module correlation to other modules MEs_R &lt;- bicor(MEs, MEs, maxPOutliers = 0.05) ## Warning in bicor(MEs, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;x&#39;. Pearson correlation was used for individual columns with zero (or missing) MAD. ## Warning in bicor(MEs, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;y&#39;. Pearson correlation was used for individual columns with zero (or missing) MAD. idx.r &lt;- which(rownames(MEs_R) == &quot;ME0&quot;) idx.c &lt;- which(colnames(MEs_R) == &quot;ME0&quot;) MEs_R_noME0 &lt;- MEs_R[-idx.r, -idx.c] MEs_R[upper.tri(MEs_R_noME0)] %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;correlation&quot; = &quot;.&quot;) %&gt;% ggplot(aes(x=correlation)) + geom_density() + ggtitle(paste0(prefix,&quot;ME correlation density\\n without &quot;,prefix ,&quot;ME0&quot;)) -&gt; MEs_R_density pheatmap::pheatmap(MEs_R, color = colorRampPalette(c(&quot;Blue&quot;, &quot;White&quot;, &quot;Red&quot;))(100), silent = T, breaks = seq(-1,1,length.out = 101), treeheight_row = 5, treeheight_col = 5, main = paste0(prefix,&quot;ME correlation heatmap&quot;), labels_row = paste0(prefix, rownames(MEs_R)), labels_col = paste0(prefix, colnames(MEs_R))) -&gt; MEs_R_Corr cowplot::plot_grid(MEs_R_density, MEs_R_Corr$gtable, labels = c(&quot;D&quot;, &quot;E&quot;), label_size = plot_labeling_size, rel_widths = c(0.6, 1)) -&gt; density_eigen density_eigen ## Display module info all(rownames(seq_tab_filter) == rownames(MEs)) ## [1] TRUE dim(seq_tab_filter) %&gt;% paste0(c(&quot; samples&quot;, &quot; OTUs&quot;)) ## [1] &quot;45 samples&quot; &quot;231 OTUs&quot; kME &lt;- bicor(seq_tab_filter, MEs, maxPOutliers = 0.05) ## Warning in bicor(seq_tab_filter, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;x&#39;. Pearson correlation was used for individual columns with zero (or missing) ## MAD. ## Warning in bicor(seq_tab_filter, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;y&#39;. Pearson correlation was used for individual columns with zero (or missing) ## MAD. dim(kME) %&gt;% paste0(c(&quot; OTUs&quot;, &quot; modules&quot;)) ## [1] &quot;231 OTUs&quot; &quot;6 modules&quot; 2.3.4.1 Plot intramodular correlation How the OTUs within a module correlates to the module eigengene. intra_cor &lt;- c() for (i in 1:ncol(seq_tab_filter)) { m &lt;- modules.otu$colors[i] intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] if(m != 0){ intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] } else{ intra_cor[i] &lt;- NA } } idx &lt;- which(is.na(intra_cor)) intra_cor &lt;- intra_cor[-idx] plot(density(intra_cor), main = &quot;Correlations with module-eigenOTU (within module correlation)\\nNo ME0&quot;, xlim = c(-1,1)) 2.3.4.2 Plot intramodular correlation for each module Plot intramodular correlation for each module individually, and color by module color. # Corr within modules corr_within_module &lt;- function(seq_tab_filter, modules, module_x = 1){ idx.omics_data &lt;- which(modules$colors == module_x) idx.me &lt;- which(colnames(modules$MEs) == paste0(&quot;ME&quot;,module_x)) kME_x &lt;- bicor(seq_tab_filter[,idx.omics_data], modules$MEs[,idx.me], maxPOutliers = 0.05) kME_x } ggplot.list &lt;- list() for(m in colnames(modules.otu$MEs)){ h &lt;- as.numeric(sub(&quot;ME&quot;,&quot;&quot;, m)) data.frame(x = suppressWarnings(corr_within_module(seq_tab_filter = seq_tab_filter, modules = modules.otu, module_x = h))) %&gt;% ggplot() + geom_density(aes(x = x), fill = labels2colors(h), color = &quot;black&quot;, alpha = 0.5) + xlim(-1, 1) + xlab(&quot;OTU correlation&quot;)+ ggtitle(paste0(prefix,m)) -&gt; da_plot ggplot.list[[m]] &lt;- da_plot } ggplot.list &lt;- ggplot.list[ggplot.list %&gt;% names() %&gt;% sub(&quot;ME&quot;, &quot;&quot;, .) %&gt;% as.numeric() %&gt;% order()] cowplot::plot_grid(plotlist = ggplot.list, ncol = 2) -&gt; density_all_plot density_all_plot ## Combine to one plot cowplot::plot_grid(si_mc_plot , density_eigen, ncol = 1, rel_heights = c(0.8,1)) -&gt; part_1 cowplot::plot_grid(part_1, module_size_barplot, labels = c(&quot;&quot;, &quot;C&quot;), label_size = plot_labeling_size, rel_widths = c(1,0.5)) -&gt; part_2 cowplot::plot_grid(part_2, density_all_plot, ncol = 1, rel_heights = c(0.8,1), labels = c(&quot;&quot;, &quot;F&quot;), label_size = plot_labeling_size) 2.3.5 Find Hub ASV For each module it is possible to pick a hub ASV with the function chooseTopHubInEachModule. hubs %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;OTU_name&quot; = &quot;.&quot;) %&gt;% tibble::rownames_to_column(var = &quot;Module&quot;) -&gt; hubOTUs dplyr::left_join(hubOTUs, (taxa_tb %&gt;% tibble::rownames_to_column(var = &quot;OTU_name&quot;)), by = &quot;OTU_name&quot;) -&gt; hubOTUs hubOTUs ## Module OTU_name Kingdom Phylum Class Order Family Genus Species ## 1 0 ASV75 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides &lt;NA&gt; ## 2 1 ASV20 Bacteria Firmicutes Clostridia Clostridiales Lachnospiraceae Dorea longicatena ## 3 2 ASV248 Bacteria Firmicutes Clostridia Clostridiales Lachnospiraceae Blautia &lt;NA&gt; ## 4 3 ASV222 Bacteria Firmicutes Clostridia Clostridiales Peptostreptococcaceae &lt;NA&gt; &lt;NA&gt; ## 5 4 ASV237 Bacteria Bacteroidetes Bacteroidia Bacteroidales Bacteroidaceae Bacteroides &lt;NA&gt; ## 6 5 ASV214 Bacteria Firmicutes Erysipelotrichia Erysipelotrichales Erysipelotrichaceae Holdemanella &lt;NA&gt; res &lt;- hubOTUs[, c(1,2,4,7)] colnames(res) &lt;- c(&quot;Module&quot;, &quot;OTU&quot;, &quot;Phylum&quot;,&quot;Genus&quot;) print(res) ## Module OTU Phylum Genus ## 1 0 ASV75 Bacteroidetes Bacteroidaceae ## 2 1 ASV20 Firmicutes Lachnospiraceae ## 3 2 ASV248 Firmicutes Lachnospiraceae ## 4 3 ASV222 Firmicutes Peptostreptococcaceae ## 5 4 ASV237 Bacteroidetes Bacteroidaceae ## 6 5 ASV214 Firmicutes Erysipelotrichaceae 2.3.6 Visualize Network 2.3.6.1 Construct network with igragh load(file = &quot;/share/projects/Analytics/analytics/MultiOmics/tools/Bookdown/result/16S_network_module-block.1.RData&quot;) # The TOM is saved as a dist object and needs to be converted to a matrix TOM &lt;- as.matrix(TOM) # Add OTU names to the TOM matrix. It is symmetrical so rownames = colnames rownames(TOM) &lt;- colnames(TOM) &lt;- names(modules.otu$colors) ## Choose taxonomic level should the graph be colored with in addition to modules? selected_taxa &lt;- &quot;Phylum&quot; ## Convert module labels and taxonomy to hex colors taxonomy_info &lt;- taxa_tb %&gt;% rownames_to_column(var = &quot;OTU_name&quot;) %&gt;% dplyr::select(&quot;OTU_name&quot;, selected_taxa) %&gt;% mutate_all(.funs = list(as.character)) module_info &lt;- modules.otu$colors %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;OTU_name&quot;) %&gt;% dplyr::rename(Module = &quot;.&quot;) ## 选择指定模块 TOM &lt;- TOM[module_info$OTU_name, module_info$OTU_name] graph_info &lt;- left_join(module_info, taxonomy_info, by = &quot;OTU_name&quot;) ## Converts R-colors to hex colors color2hex &lt;- function(x){ x &lt;- col2rgb(x) rgb(x[1,], x[2,], x[3,], maxColorValue = 255) } ## Add specific colors to the taxa taxa_colors &lt;- graph_info %&gt;% dplyr::select(selected_taxa) %&gt;% unique() %&gt;% mutate(tax_color = colorRampPalette(RColorBrewer::brewer.pal(8, &quot;Accent&quot;))(nrow(.))) graph_info_colors &lt;- left_join(graph_info, taxa_colors) %&gt;% mutate(module_color = WGCNA::labels2colors(Module)) %&gt;% mutate(module_color = color2hex(module_color)) %&gt;% mutate(module_color = paste0(module_color,70)) ## Joining, by = &quot;Phylum&quot; ## If all lines are too thick, reduce the strength (between 0 and 1). ## The lower the number the weaker the lines. strength_adjust = 1 g &lt;- graph.adjacency(TOM, mode=&quot;undirected&quot;, weighted= TRUE) #~https://stackoverflow.com/questions/28366329/how-to-scale-edge-colors-igraph igraph::delete.edges(g, which(E(g)$weight &lt;1)) ## IGRAPH 4238ed3 UNW- 231 0 -- ## + attr: name (v/c), weight (e/n) ## + edges from 4238ed3 (vertex names): E(g)$width &lt;- E(g)$weight*strength_adjust + min(E(g)$weight) set.seed(231) # Ensures the same layout given the same data. l &lt;- layout_with_fr(g, weights = E(g)$weight) # Order graph_info_colors by the graph graph_info_colors &lt;- graph_info_colors[which(graph_info_colors$OTU_name %in% V(g)$name),] # Ensure that the names are in the same order if(all(V(g)$name == graph_info_colors$OTU_name)){cat(&quot;\\nOTU names match&quot;)} ## ## OTU names match # Add square shapes to hub OTUs V(g)$shape &lt;- ifelse(V(g)$name %in% hubs[-1], &quot;square&quot;, &quot;circle&quot;) #-1 means dont use module 0 # OTUs in modules have larger nodes V(g)$size &lt;- ifelse(graph_info_colors$Module != 0, 10, 5) # And larger text V(g)$label.cex &lt;- ifelse(graph_info_colors$Module != 0, 0.8, 0.4) # Remove everything but the number to increase readability V(g)$name = sub(&quot;OTU_&quot;, &quot;&quot;, graph_info_colors$OTU_name) 2.3.6.2 Plot network ## Find distinct entires for the plot legends module_labels &lt;- graph_info_colors %&gt;% dplyr::select(Module, module_color) %&gt;% distinct() %&gt;% arrange(Module) tax_labels &lt;- graph_info_colors %&gt;% dplyr::select(selected_taxa, tax_color) %&gt;% distinct() ## Plot the graphs, leftmost is colored by module, rightmost is colored by taxonomic classification par(mfrow = c(1,2)) par(mar = c(0,0,0,0)) plot(g, layout = l, vertex.color = graph_info_colors$module_color) # legend(&quot;topleft&quot;, legend = paste0(&quot;mM&quot;, 0:(nrow(module_labels)-1)), fill=module_labels$module_color) legend(&quot;topleft&quot;, legend = paste0(&quot;mM&quot;, 0:(nrow(module_labels)-1)), fill=module_labels$module_color) plot(g, layout = l, vertex.color = graph_info_colors$tax_color) legend(&quot;topleft&quot;, legend = tax_labels %&gt;% .[,1], fill=tax_labels$tax_color) par(mfrow = c(1,1)) 2.3.7 Clean env of 16S data analysis rm(list=ls()) 2.4 WGCNA for MGS data MGS data from GvHD project (32 samples with 250 species features) was used as demo data in this sub-chapter. 2.4.1 Data loading (WGCNA MGS) 2.4.1.1 Read demo input files (WGCNA MGS) mgs_profile &lt;- read.table(&quot;/share/projects/Analytics/analytics/MultiOmics/tools/HAllA/GvHD/metaphlan2_merged.tsv&quot;, header = TRUE, sep = &quot;\\t&quot;) # read metagenomic hirerachy table，only need ID column mgs &lt;- read.table(&quot;/share/projects/Analytics/analytics/MultiOmics/tools/HAllA/GvHD/metagenomics.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) # read metagenomic species level data metadata &lt;- read.table(&quot;/share/projects/Analytics/analytics/MultiOmics/tools/HAllA/GvHD/metadata.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) # read metadata dim(mgs_profile) ## [1] 1028 69 dim(mgs) ## [1] 250 32 dim(metadata) ## [1] 15 32 cat(&quot;[mgs]&quot;, paste(c(&quot;Feature: &quot;, &quot;Sample: &quot;), dim(mgs))) ## [mgs] Feature: 250 Sample: 32 2.4.1.2 Construct the hierarchy table for taxa data # taxa hierarchy table mgs_species &lt;- mgs_profile %&gt;% .[sapply(str_split(mgs_profile$ID, &quot;\\\\|&quot;), function(x) length(x) == 7), ] taxa_table &lt;- str_split_fixed(mgs_species$ID,&quot;\\\\|&quot;, 7) %&gt;% as.data.frame() colnames(taxa_table) &lt;- c(&quot;Kingdom&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;, &quot;Species&quot;) rownames(taxa_table) &lt;- str_replace(taxa_table$Species, &quot;s__&quot;, &quot;&quot;) 2.4.2 Data normalization (WGCNA MGS) data.metagenomeSeq &lt;- metagenomeSeq::newMRexperiment(mgs) # Variables as rows, samples as columns p &lt;- metagenomeSeq::cumNormStat(data.metagenomeSeq) ## Default value being used. data.cumnorm &lt;- metagenomeSeq::cumNorm(data.metagenomeSeq, p=p) mgs &lt;- metagenomeSeq::MRcounts(data.cumnorm, norm=TRUE, log=TRUE) # log here is a +1 shifted log2 dim(mgs) ## [1] 250 32 mgs_t &lt;- mgs %&gt;% t() # Samples as rows, Features as columns 2.4.3 Build WGCNA network (WGCNA MGS) Before running this chunk and the the chunks onwards, please make sure that your data has been normalized. 2.4.3.1 select power (WGCNA MGS) powers &lt;- c(1:10, seq(12,20,2)) # default suppressWarnings(sft &lt;- pickSoftThreshold(mgs_t, powerVector = powers, verbose = 1, networkType = &quot;signed&quot;, corFn= &quot;bicor&quot;)) ## pickSoftThreshold: will use block size 250. ## pickSoftThreshold: calculating connectivity for given powers... \b..0% \b\b\b\b\b..100% ## Power SFT.R.sq slope truncated.R.sq mean.k. median.k. max.k. ## 1 1 0.6250 10.900 0.768 134.00 135.000 150.00 ## 2 2 0.6400 4.310 0.814 75.60 75.700 93.20 ## 3 3 0.5870 2.560 0.867 44.70 44.700 60.90 ## 4 4 0.3110 1.210 0.715 27.80 27.900 41.70 ## 5 5 0.2170 0.761 0.623 18.20 17.900 29.70 ## 6 6 0.2000 0.561 0.699 12.50 12.100 21.80 ## 7 7 0.1940 0.438 0.730 9.05 8.830 16.40 ## 8 8 0.0156 0.114 0.753 6.80 6.510 13.60 ## 9 9 0.0476 -0.223 0.620 5.30 4.830 11.80 ## 10 10 0.1870 -0.526 0.470 4.26 3.720 10.50 ## 11 12 0.5040 -0.857 0.661 2.99 2.310 8.89 ## 12 14 0.6820 -0.965 0.666 2.27 1.470 7.93 ## 13 16 0.7330 -1.080 0.659 1.84 1.070 7.33 ## 14 18 0.8160 -1.020 0.804 1.57 0.777 6.94 ## 15 20 0.8010 -0.986 0.808 1.38 0.587 6.67 # Find the soft thresholding power beta to which co-expression similarity is raised to calculate adjacency. # based on the criterion of approximate scale-free topology. idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.90)) if(is.infinite(idx)){ idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.80)) if(!is.infinite(idx)){ st &lt;- sft$fitIndices[idx,1] } else{ idx &lt;- which.max(-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) st &lt;- sft$fitIndices[idx,1] } } else{ st &lt;- sft$fitIndices[idx,1] } # Plot Scale independence measure and Mean connectivity measure # Scale-free topology fit index as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], sfApprox = -sign(sft$fitIndices[,3])*sft$fitIndices[,2]) %&gt;% ggplot() + geom_hline(yintercept = 0.9, color = &quot;red&quot;, alpha = 0.6) + # corresponds to R^2 cut-off of 0.9 geom_hline(yintercept = 0.8, color = &quot;red&quot;, alpha = 0.2) + # corresponds to R^2 cut-off of 0.8 geom_line(aes(x = Indices, y = sfApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = sfApprox, label = Indices), color = &quot;red&quot;, size = 4) + ggtitle(&quot;Scale independence&quot;) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;SF Model Fit,signed R^2&quot;) + xlim(1,20) + ylim(-1,1) + geom_segment(aes(x = st, y = 0.25, xend = st, yend = sfApprox[idx]-0.05), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.5)-&gt; scale_independence_plot # Mean connectivity as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], meanApprox = sft$fitIndices[,5]) %&gt;% ggplot() + geom_line(aes(x = Indices, y = meanApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = meanApprox, label = Indices), color = &quot;red&quot;, size = 4) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;Mean Connectivity&quot;) + geom_segment(aes(x = st-0.4, y = sft$fitIndices$mean.k.[idx], xend = 0, yend = sft$fitIndices$mean.k.[idx]), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.4) + ggtitle(paste0(&quot;Mean connectivity: &quot;, round(sft$fitIndices$mean.k.[idx],2))) -&gt; mean_connectivity_plot cowplot::plot_grid(scale_independence_plot, mean_connectivity_plot, ncol = 2, align = &quot;h&quot;, labels = c(&quot;A&quot;, &quot;B&quot;), label_size = 15) -&gt; si_mc_plot si_mc_plot The number closest to the 0.8 line is 18, and the constructed adjacency matrix most closely fits with scale-free topology. Therefore power is 18. 2.4.3.2 Block-wise network construction and module detection (WGCNA MGS) The function blockwiseModules will first pre cluster with fast crude clustering method to cluster OTUs into blocks not exceeding the maximum, blocks may therefore not be fully optimal in the end. Change the parameters here to better reflect your own data. if(!dir.exists(&quot;./result/&quot;)) { dir.create(&quot;./result/&quot;) } Run_analysis &lt;- TRUE if(Run_analysis){ modules.mgs &lt;- blockwiseModules(mgs_t, power = st, networkType = &quot;signed&quot;, TOMType = &quot;signed&quot;, corType = &#39;bicor&#39;, maxPOutliers = 0.05, deepSplit = 2, pamStage = FALSE, pamRespectsDendro = TRUE, mergeCutHeight = 0.25, replaceMissingAdjacencies = TRUE, minModuleSize = 5, # There are fewer otus than genes, and that many might not be connected numericLabels = TRUE, saveTOMs = TRUE, saveTOMFileBase = &quot;./result/modules.mgs&quot;, #&quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/GVHD/bookdown_GVHD/result/modules.mgs&quot;, verbose = 1) rownames(modules.mgs$MEs) &lt;- rownames(mgs_t) names(modules.mgs$colors) &lt;- colnames(mgs_t) names(modules.mgs$unmergedColors) &lt;- colnames(mgs_t) hubs.mgs &lt;- chooseTopHubInEachModule(mgs_t, modules.mgs$colors) } ## Calculating module eigengenes block-wise from all genes 2.4.3.3 mgs module details (WGCNA MGS) ## Convert labels to colors for plotting merged_colors &lt;- labels2colors(modules.mgs$colors) n_modules &lt;- unique(merged_colors) %&gt;% length() samples_good &lt;- sum(modules.mgs$goodSamples) == length(modules.mgs$goodSamples) OTUs_good &lt;- sum(modules.mgs$goodGenes) == length(modules.mgs$goodGenes) ME_good &lt;- sum(modules.mgs$MEsOK) == length(modules.mgs$MEsOK) All samples are OK. All OTUs are OK. There where 8 modules found. All module eigenOTUs are OK. 2.4.3.4 plot mgs module details (WGCNA MGS) table(modules.mgs$colors) %&gt;% as.data.frame() %&gt;% dplyr::rename(Module = Var1, Size = Freq) %&gt;% dplyr::mutate(Module_color = labels2colors(as.numeric(as.character(Module)))) -&gt; module_size module_size %&gt;% ggplot(aes(x = Module, y = Size, fill = Module)) + geom_col(color = &quot;#000000&quot;) + ggtitle(&quot;Number of OTUs in each module&quot;) + theme(legend.position = &quot;none&quot;) + scale_fill_manual(values = setNames(module_size$Module_color,module_size$Module)) + geom_text(aes(label = Size),vjust = 0.5, hjust = -0.18, size = 3.5) + ylim(0, max(module_size$Size)*1.1) + theme(plot.margin = margin(2, 2, 2, 2, &quot;pt&quot;)) + coord_flip()-&gt; module_size_barplot module_size_barplot 2.4.3.5 Cluster modules (WGCNA MGS) plotEigengeneNetworks(modules.mgs$MEs, &quot;Eigengene adjacency heatmap&quot;, marDendro = c(3,3,2,4), marHeatmap = c(3,4,2,2), plotDendrograms = T, xLabelsAngle = 90) table(modules.mgs$colors) %&gt;% as.data.frame() -&gt; res res$`Module color` &lt;- WGCNA::labels2colors(as.numeric(as.character(res$Var1))) res &lt;- res[, c(1,3,2)] colnames(res) &lt;- c(&quot;Module&quot;, &quot;Module color&quot;, &quot;Number of OTUs&quot;) print(res) ## Module Module color Number of OTUs ## 1 0 grey 174 ## 2 1 turquoise 20 ## 3 2 blue 13 ## 4 3 brown 12 ## 5 4 yellow 10 ## 6 5 green 9 ## 7 6 red 7 ## 8 7 black 5 2.4.3.6 Plot dendrogram of module clusters (WGCNA MGS) # Plot the dendrogram and the module colors underneath for each block for(i in seq_along(modules.mgs$dendrograms)){ plotDendroAndColors(modules.mgs$dendrograms[[i]], merged_colors[modules.mgs$blockGenes[[i]]], &quot;Module colors&quot;, dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = paste0(&quot;Cluster Dendrogram\\n&quot;, &quot;for block &quot;, i,&quot;: &quot;, length(modules.mgs$blockGenes[[i]]), &quot; OTUs&quot;)) } 2.4.3.7 Module (Eigengene) correlation (WGCNA MGS) MEs &lt;- modules.mgs$MEs # Module correlation to other modules MEs_R &lt;- bicor(MEs, MEs, maxPOutliers = 0.05) ## Warning in bicor(MEs, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;x&#39;. Pearson correlation was used for individual columns with zero (or missing) MAD. ## Warning in bicor(MEs, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;y&#39;. Pearson correlation was used for individual columns with zero (or missing) MAD. idx.r &lt;- which(rownames(MEs_R) == &quot;ME0&quot;) idx.c &lt;- which(colnames(MEs_R) == &quot;ME0&quot;) MEs_R_noME0 &lt;- MEs_R[-idx.r, -idx.c] MEs_R[upper.tri(MEs_R_noME0)] %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;correlation&quot; = &quot;.&quot;) %&gt;% ggplot(aes(x=correlation)) + geom_density() + ggtitle(paste0(&quot;mgs&quot;,&quot;ME correlation density\\n without &quot;,&quot;mgs&quot; ,&quot;ME0&quot;)) -&gt; MEs_R_density pheatmap::pheatmap(MEs_R, color = colorRampPalette(c(&quot;Blue&quot;, &quot;White&quot;, &quot;Red&quot;))(100), silent = T, breaks = seq(-1,1,length.out = 101), treeheight_row = 5, treeheight_col = 5, main = paste0(&quot;mgs&quot;,&quot;ME correlation heatmap&quot;), labels_row = paste0(&quot;mgs&quot;, rownames(MEs_R)), labels_col = paste0(&quot;mgs&quot;, colnames(MEs_R))) -&gt; MEs_R_Corr cowplot::plot_grid(MEs_R_density, MEs_R_Corr$gtable, labels = c(&quot;D&quot;, &quot;E&quot;), label_size = 15, rel_widths = c(0.6, 1)) -&gt; density_eigen density_eigen all(rownames(mgs_t) == rownames(MEs)) ## [1] TRUE dim(mgs_t) %&gt;% paste0(c(&quot; samples&quot;, &quot; OTUs&quot;)) ## [1] &quot;32 samples&quot; &quot;250 OTUs&quot; kME &lt;- bicor(mgs_t, MEs, maxPOutliers = 0.05) ## Warning in bicor(mgs_t, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;x&#39;. Pearson correlation was used for individual columns with zero (or missing) MAD. ## Warning in bicor(mgs_t, MEs, maxPOutliers = 0.05): bicor: zero MAD in variable &#39;y&#39;. Pearson correlation was used for individual columns with zero (or missing) MAD. dim(kME) %&gt;% paste0(c(&quot; OTUs&quot;, &quot; modules&quot;)) ## [1] &quot;250 OTUs&quot; &quot;8 modules&quot; 2.4.3.8 Show plots of the intra modular correlation ## How the OTUs within a module correlates to the module eigengene intra_cor &lt;- c() for (i in 1:ncol(mgs_t)) { m &lt;- modules.mgs$colors[i] intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] if(m != 0){ intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] } else{ intra_cor[i] &lt;- NA } } idx &lt;- which(is.na(intra_cor)) intra_cor &lt;- intra_cor[-idx] plot(density(intra_cor), main = &quot;Correlations with module-eigenOTU (within module correlation)\\nNo ME0&quot;, xlim = c(-1,1)) ## Show the same thing, but for each module individually, and color by module color. # Corr within modules corr_within_module &lt;- function(mgs_t, modules, module_x = 1){ idx.omics_data &lt;- which(modules$colors == module_x) idx.me &lt;- which(colnames(modules$MEs) == paste0(&quot;ME&quot;,module_x)) kME_x &lt;- bicor(mgs_t[,idx.omics_data], modules$MEs[,idx.me], maxPOutliers = 0.05) kME_x } ggplot.list &lt;- list() for(m in colnames(modules.mgs$MEs)){ h &lt;- as.numeric(sub(&quot;ME&quot;,&quot;&quot;, m)) data.frame(x = suppressWarnings(corr_within_module(mgs_t = mgs_t, modules = modules.mgs, module_x = h))) %&gt;% ggplot() + geom_density(aes(x = x), fill = labels2colors(h), color = &quot;black&quot;, alpha = 0.5) + xlim(-1, 1) + xlab(&quot;OTU correlation&quot;)+ ggtitle(paste0(&quot;mgs&quot;,m)) -&gt; da_plot ggplot.list[[m]] &lt;- da_plot } ggplot.list &lt;- ggplot.list[ggplot.list %&gt;% names() %&gt;% sub(&quot;ME&quot;, &quot;&quot;, .) %&gt;% as.numeric() %&gt;% order()] cowplot::plot_grid(plotlist = ggplot.list, ncol = 2) -&gt; density_all_plot density_all_plot Combine to one plot cowplot::plot_grid(si_mc_plot , density_eigen, ncol = 1, rel_heights = c(0.8,1)) -&gt; part_1 cowplot::plot_grid(part_1, module_size_barplot, labels = c(&quot;&quot;, &quot;C&quot;), label_size = 15, rel_widths = c(1,0.5)) -&gt; part_2 cowplot::plot_grid(part_2, density_all_plot, ncol = 1, rel_heights = c(0.8,1), labels = c(&quot;&quot;, &quot;F&quot;), label_size = 15) 2.4.3.9 Hub genes (WGCNA MGS) For each module it is possible to pick a hub gene with the function chooseTopHubInEachModule. hubs.mgs %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;OTU_name&quot; = &quot;.&quot;) %&gt;% tibble::rownames_to_column(var = &quot;Module&quot;) -&gt; hubOTUs dplyr::left_join(hubOTUs, (taxa_table %&gt;% tibble::rownames_to_column(var = &quot;OTU_name&quot;)), by = &quot;OTU_name&quot;) -&gt; hubOTUs hubOTUs %&gt;% datatable() 2.5 WGCNA for metabolic data Metabolite data from GvHD project (32 samples with 811 metabolite features) was used as demo data in this sub-chapter. 2.5.1 Data loading (WGCNA metabolites) 2.5.1.1 Read demo input files (WGCNA metabolites) metabolites_level &lt;- read.xlsx(&quot;/share/projects/Analytics/analytics/MultiOmics/tools/HAllA/GvHD/ALL_sample_data.xlsx&quot;, sheetIndex = 1) # read metabolic hirerachy table metabolites_data &lt;- read.table(&quot;/share/projects/Analytics/analytics/MultiOmics/tools/HAllA/GvHD/metabolic.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) # read metabolic data dim(metabolites_level) ## [1] 1235 78 dim(metabolites_data) ## [1] 811 32 cat(&quot;[metabolites]&quot;, paste0(c(&quot;Feature: &quot;, &quot;Sample: &quot;), dim(metabolites_data))) ## [metabolites] Feature: 811 Sample: 32 2.5.1.2 Construct metabolic hierarchy table (WGCNA metabolites) metabolites_level &lt;- metabolites_level %&gt;% select(Index, Class.I, Class.II) metabolites_level &lt;- metabolites_level %&gt;% column_to_rownames(&quot;Index&quot;) metabolites_t &lt;- metabolites_data %&gt;% t() 2.5.2 Build WGCNA network (WGCNA metabolites) 2.5.2.1 Select power (WGCNA metabolites) powers &lt;- c(1:10, seq(12,20,2)) suppressWarnings(sft &lt;- pickSoftThreshold(metabolites_t, powerVector = powers, verbose = 1, networkType = &quot;signed&quot;, corFn= &quot;bicor&quot;)) ## pickSoftThreshold: will use block size 811. ## pickSoftThreshold: calculating connectivity for given powers... \b..0% \b\b\b\b\b..100% ## Power SFT.R.sq slope truncated.R.sq mean.k. median.k. max.k. ## 1 1 0.72200 9.9100 0.756 456.00 462.00 520.0 ## 2 2 0.79300 4.6000 0.924 273.00 278.00 345.0 ## 3 3 0.75800 2.8500 0.951 172.00 175.00 238.0 ## 4 4 0.57200 1.7000 0.941 113.00 113.00 176.0 ## 5 5 0.26700 0.7160 0.932 76.60 76.00 134.0 ## 6 6 0.00268 0.0619 0.861 53.80 52.30 108.0 ## 7 7 0.11500 -0.3880 0.920 38.90 36.70 89.5 ## 8 8 0.30800 -0.7520 0.901 28.90 26.60 75.3 ## 9 9 0.41300 -0.9160 0.918 22.00 19.40 64.3 ## 10 10 0.53800 -1.2300 0.901 17.00 14.50 55.5 ## 11 12 0.64600 -1.5400 0.935 10.80 8.60 42.5 ## 12 14 0.71500 -1.6400 0.954 7.32 5.48 33.4 ## 13 16 0.75500 -1.6800 0.960 5.23 3.52 26.8 ## 14 18 0.77000 -1.7300 0.946 3.90 2.49 21.9 ## 15 20 0.74400 -1.7800 0.912 3.03 1.74 18.1 # Find the soft thresholding power beta to which co-expression similarity is raised to calculate adjacency. # based on the criterion of approximate scale-free topology. idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.90)) if(is.infinite(idx)){ idx &lt;- min(which((-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) &gt; 0.80)) if(!is.infinite(idx)){ st &lt;- sft$fitIndices[idx,1] } else{ idx &lt;- which.max(-sign(sft$fitIndices[,3])*sft$fitIndices[,2]) st &lt;- sft$fitIndices[idx,1] } } else{ st &lt;- sft$fitIndices[idx,1] } # Plot Scale independence measure and Mean connectivity measure # Scale-free topology fit index as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], sfApprox = -sign(sft$fitIndices[,3])*sft$fitIndices[,2]) %&gt;% ggplot() + geom_hline(yintercept = 0.9, color = &quot;red&quot;, alpha = 0.6) + # corresponds to R^2 cut-off of 0.9 geom_hline(yintercept = 0.8, color = &quot;red&quot;, alpha = 0.2) + # corresponds to R^2 cut-off of 0.8 geom_line(aes(x = Indices, y = sfApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = sfApprox, label = Indices), color = &quot;red&quot;, size = 4) + ggtitle(&quot;Scale independence&quot;) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;SF Model Fit,signed R^2&quot;) + xlim(1,20) + ylim(-1,1) + geom_segment(aes(x = st, y = 0.25, xend = st, yend = sfApprox[idx]-0.05), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.5)-&gt; scale_independence_plot # Mean connectivity as a function of the soft-thresholding power data.frame(Indices = sft$fitIndices[,1], meanApprox = sft$fitIndices[,5]) %&gt;% ggplot() + geom_line(aes(x = Indices, y = meanApprox), color = &quot;red&quot;, alpha = 0.1, size = 2.5) + geom_text(mapping = aes(x = Indices, y = meanApprox, label = Indices), color = &quot;red&quot;, size = 4) + xlab(&quot;Soft Threshold (power)&quot;) + ylab(&quot;Mean Connectivity&quot;) + geom_segment(aes(x = st-0.4, y = sft$fitIndices$mean.k.[idx], xend = 0, yend = sft$fitIndices$mean.k.[idx]), arrow = arrow(length = unit(0.2,&quot;cm&quot;)), size = 0.4) + ggtitle(paste0(&quot;Mean connectivity: &quot;, round(sft$fitIndices$mean.k.[idx],2))) -&gt; mean_connectivity_plot cowplot::plot_grid(scale_independence_plot, mean_connectivity_plot, ncol = 2, align = &quot;h&quot;, labels = c(&quot;A&quot;, &quot;B&quot;), label_size = 15) -&gt; si_mc_plot si_mc_plot The power is 18 2.5.2.2 Block-wise network construction and module detection (WGCNA metabolites) The function blockwiseModules will first pre cluster with fast crude clustering method to cluster OTUs into blocks not exceeding the maximum, blocks may therefore not be fully optimal in the end. Change the parameters here to better reflect your own data. Run_analysis &lt;- TRUE if(Run_analysis){ modules.metabolites &lt;- blockwiseModules(metabolites_t, power = st, networkType = &quot;signed&quot;, TOMType = &quot;signed&quot;, corType = &#39;bicor&#39;, maxPOutliers = 0.05, deepSplit = 2, pamStage = FALSE, pamRespectsDendro = TRUE, mergeCutHeight = 0.25, replaceMissingAdjacencies = TRUE, minModuleSize = 5, # There are fewer otus than genes, and that many might not be connected numericLabels = TRUE, saveTOMs = TRUE, saveTOMFileBase = &quot;./result/module.metabolites&quot;, #&quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/GVHD/bookdown_GVHD/result/module.metabolites&quot;, verbose = 1) rownames(modules.metabolites$MEs) &lt;- rownames(metabolites_t) names(modules.metabolites$colors) &lt;- colnames(metabolites_t) names(modules.metabolites$unmergedColors) &lt;- colnames(metabolites_t) hubs.metabolites &lt;- chooseTopHubInEachModule(metabolites_t, modules.metabolites$colors) } ## Calculating module eigengenes block-wise from all genes 2.5.2.3 metabolites module details (WGCNA metabolites) # Convert labels to colors for plotting merged_colors &lt;- labels2colors(modules.metabolites$colors) n_modules &lt;- unique(merged_colors) %&gt;% length() samples_good &lt;- sum(modules.metabolites$goodSamples) == length(modules.metabolites$goodSamples) OTUs_good &lt;- sum(modules.metabolites$goodGenes) == length(modules.metabolites$goodGenes) ME_good &lt;- sum(modules.metabolites$MEsOK) == length(modules.metabolites$MEsOK) All samples are OK. All OTUs are OK. There where 27 modules found. All module eigenOTUs are OK. How many Metabolites are there in each module? table(modules.metabolites$colors) %&gt;% as.data.frame() %&gt;% dplyr::rename(Module = Var1, Size = Freq) %&gt;% dplyr::mutate(Module_color = labels2colors(as.numeric(as.character(Module)))) -&gt; module_size module_size %&gt;% ggplot(aes(x = Module, y = Size, fill = Module)) + geom_col(color = &quot;#000000&quot;) + ggtitle(&quot;Number of Metabolites in each module&quot;) + theme(legend.position = &quot;none&quot;) + scale_fill_manual(values = setNames(module_size$Module_color,module_size$Module)) + geom_text(aes(label = Size),vjust = 0.5, hjust = -0.18, size = 3.5) + ylim(0, max(module_size$Size)*1.1) + theme(plot.margin = margin(2, 2, 2, 2, &quot;pt&quot;)) + coord_flip()-&gt; module_size_barplot module_size_barplot cluster relationships between the module # labels2colors(modules.metabolites$colors) plotEigengeneNetworks(modules.metabolites$MEs, &quot;Eigengene adjacency heatmap&quot;, marDendro = c(3,3,2,4), marHeatmap = c(3,4,2,2), plotDendrograms = T, xLabelsAngle = 90) table(modules.metabolites$colors) %&gt;% as.data.frame() -&gt; res res$`Module color` &lt;- WGCNA::labels2colors(as.numeric(as.character(res$Var1))) res &lt;- res[, c(1,3,2)] colnames(res) &lt;- c(&quot;Module&quot;, &quot;Module color&quot;, &quot;Number of metabolic&quot;) print(res %&gt;% datatable()) Dendrogram and module colors # Plot the dendrogram and the module colors underneath for each block for(i in seq_along(modules.metabolites$dendrograms)){ plotDendroAndColors(modules.metabolites$dendrograms[[i]], merged_colors[modules.metabolites$blockGenes[[i]]], &quot;Module colors&quot;, dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = paste0(&quot;Cluster Dendrogram\\n&quot;, &quot;for block &quot;, i,&quot;: &quot;, length(modules.metabolites$blockGenes[[i]]), &quot; metabolic&quot;)) } Module (Eigengene) correlation (metabolites) MEs &lt;- modules.metabolites$MEs # Module correlation to other modules MEs_R &lt;- bicor(MEs, MEs, maxPOutliers = 0.05) idx.r &lt;- which(rownames(MEs_R) == &quot;ME0&quot;) idx.c &lt;- which(colnames(MEs_R) == &quot;ME0&quot;) MEs_R_noME0 &lt;- MEs_R[-idx.r, -idx.c] MEs_R[upper.tri(MEs_R_noME0)] %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;correlation&quot; = &quot;.&quot;) %&gt;% ggplot(aes(x=correlation)) + geom_density() + ggtitle(paste0(&quot;mbs&quot;,&quot;ME correlation density\\n without &quot;,&quot;mbs&quot; ,&quot;ME0&quot;)) -&gt; MEs_R_density pheatmap::pheatmap(MEs_R, color = colorRampPalette(c(&quot;Blue&quot;, &quot;White&quot;, &quot;Red&quot;))(100), silent = T, breaks = seq(-1,1,length.out = 101), treeheight_row = 5, treeheight_col = 5, main = paste0(&quot;mbs&quot;,&quot;ME correlation heatmap&quot;), labels_row = paste0(&quot;mbs&quot;, rownames(MEs_R)), labels_col = paste0(&quot;mbs&quot;, colnames(MEs_R))) -&gt; MEs_R_Corr cowplot::plot_grid(MEs_R_density, MEs_R_Corr$gtable, labels = c(&quot;D&quot;, &quot;E&quot;), label_size = 15, rel_widths = c(0.6, 1)) -&gt; density_eigen density_eigen all(rownames(metabolites_t) == rownames(MEs)) ## [1] TRUE dim(metabolites_t) %&gt;% paste0(c(&quot; samples&quot;, &quot; metabolic&quot;)) ## [1] &quot;32 samples&quot; &quot;811 metabolic&quot; kME &lt;- bicor(metabolites_t, MEs, maxPOutliers = 0.05) dim(kME) %&gt;% paste0(c(&quot; metabolic&quot;, &quot; modules&quot;)) ## [1] &quot;811 metabolic&quot; &quot;27 modules&quot; Show a plot of the intra modular correlation (metabolites) How the OTUs within a module correlates to the module eigengene. intra_cor &lt;- c() for (i in 1:ncol(metabolites_t)) { m &lt;- modules.metabolites$colors[i] intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] if(m != 0){ intra_cor[i] &lt;- kME[i, paste0(&quot;ME&quot;, m)] } else{ intra_cor[i] &lt;- NA } } idx &lt;- which(is.na(intra_cor)) intra_cor &lt;- intra_cor[-idx] plot(density(intra_cor), main = &quot;Correlations with module-eigenMBS (within module correlation)\\nNo ME0&quot;, xlim = c(-1,1)) Show the same thing, but for each module individually, and color by module color. # Corr within modules corr_within_module &lt;- function(metabolites_t, modules, module_x = 1){ idx.omics_data &lt;- which(modules$colors == module_x) idx.me &lt;- which(colnames(modules$MEs) == paste0(&quot;ME&quot;,module_x)) kME_x &lt;- bicor(metabolites_t[,idx.omics_data], modules$MEs[,idx.me], maxPOutliers = 0.05) kME_x } ggplot.list &lt;- list() for(m in colnames(modules.metabolites$MEs)){ h &lt;- as.numeric(sub(&quot;ME&quot;,&quot;&quot;, m)) data.frame(x = suppressWarnings(corr_within_module(metabolites_t = metabolites_t, modules = modules.metabolites, module_x = h))) %&gt;% ggplot() + geom_density(aes(x = x), fill = labels2colors(h), color = &quot;black&quot;, alpha = 0.5) + xlim(-1, 1) + xlab(&quot;metabolic correlation&quot;)+ ggtitle(paste0(&quot;mbs&quot;,m)) -&gt; da_plot ggplot.list[[m]] &lt;- da_plot } ggplot.list &lt;- ggplot.list[ggplot.list %&gt;% names() %&gt;% sub(&quot;ME&quot;, &quot;&quot;, .) %&gt;% as.numeric() %&gt;% order()] cowplot::plot_grid(plotlist = ggplot.list, ncol = 5) -&gt; density_all_plot # ncol 可以根据module的大小调整 density_all_plot Combine to one plot (metabolites) cowplot::plot_grid(si_mc_plot , density_eigen, ncol = 1, rel_heights = c(0.8,1)) -&gt; part_1 cowplot::plot_grid(part_1, module_size_barplot, labels = c(&quot;&quot;, &quot;C&quot;), label_size = 15, rel_widths = c(1,0.5)) -&gt; part_2 cowplot::plot_grid(part_2, density_all_plot, ncol = 1, rel_heights = c(0.8,1), labels = c(&quot;&quot;, &quot;F&quot;), label_size = 15) 2.5.2.4 Hub metabolites (WGCNA metabolites) For each module it is possible to pick a hub metabolites with the function chooseTopHubInEachModule. hubs.metabolites %&gt;% as.data.frame() %&gt;% dplyr::rename(&quot;mbs_name&quot; = &quot;.&quot;) %&gt;% tibble::rownames_to_column(var = &quot;Module&quot;) -&gt; hubMBS dplyr::left_join(hubMBS, (metabolites_level %&gt;% tibble::rownames_to_column(var = &quot;mbs_name&quot;)), by = &quot;mbs_name&quot;) -&gt; hubMBS hubMBS %&gt;% datatable() 2.6 Metabolites, mgs and metadata association In this subchapter, you will learn to associate the modules extracted from different types of data. Here we associated the modules extracted from MGS and Metabolites with cor.test funciton from stats R package. 2.6.1 Use heatmap to show the correlation of MGS and metabolites X_eigengenes &lt;- modules.metabolites$MEs # X_eigengenes is metabolic Y_eigengenes &lt;- modules.mgs$MEs # Y_eigengenes is mgs # Create a dendrogram of the metabolites eigengenes to organise the final plots. X_ME_dendro &lt;- hclust(as.dist(1 - WGCNA::bicor(X_eigengenes, maxPOutliers = 0.05)), method = &quot;ward.D2&quot;) heatmap_colors &lt;- colorRampPalette(c(&quot;#18b29f&quot;,&quot;#FFFFFF&quot;,&quot;#ac6721&quot;), interpolate = &quot;spline&quot;, space = &quot;rgb&quot;)(51) annotation_col &lt;- metadata %&gt;% t() %&gt;% as.data.frame() %&gt;% select(V1_outcome, GVHD_type, Donor) annotation_colors &lt;- list( V1_outcome = c(`CR` = &quot;#F08A46&quot;, `PR` = &quot;#8EB470&quot;, `NR` = &quot;#B7CFA4&quot;), GVHD_type = c(`aGVHD` = &quot;red&quot;, `cGVHD` = &quot;green&quot;), Donor = c(`DO1` = &quot;paleturquoise&quot;, `DO2` = &quot;palevioletred&quot;) ) X_eigengenes_to_plot &lt;- dplyr::inner_join(annotation_col %&gt;% rownames_to_column(var = &quot;sampleName&quot;), X_eigengenes %&gt;% rownames_to_column(var = &quot;sampleName&quot;), by = &quot;sampleName&quot;) %&gt;% dplyr::arrange(V1_outcome, GVHD_type, Donor) %&gt;% # The order at which the columns should appear, given that there is no clustering. dplyr::select(sampleName, starts_with(&quot;ME&quot;)) %&gt;% tibble::column_to_rownames(var = &quot;sampleName&quot;) %&gt;% t() pheatmap::pheatmap(X_eigengenes_to_plot, cluster_cols = TRUE, cluster_rows = X_ME_dendro, treeheight_row = 20, cutree_rows = 4, cutree_cols = 4, color = heatmap_colors, fontsize = 10, fontsize_col = 6, annotation_colors = annotation_colors, annotation_col = annotation_col, silent = F, labels_row = paste0(&quot;mb&quot;, rownames(X_eigengenes_to_plot)), main = paste(&quot;Metabolites Module &#39;expression&#39;\\n&quot;)) -&gt; X_plot 2.6.2 Correlate modules from metabolic and metagenomics p.value_matr &lt;- corr.value_matr &lt;- matrix(ncol = ncol(Y_eigengenes), nrow = ncol(X_eigengenes), dimnames = list(colnames(X_eigengenes), colnames(Y_eigengenes))) for(i in 1:ncol(X_eigengenes)){ for(j in 1:ncol(Y_eigengenes)){ cor.res &lt;- cor.test(X_eigengenes[,i], Y_eigengenes[,j]) p.value_matr[i, j] &lt;- cor.res$p.value corr.value_matr[i, j] &lt;- cor.res$estimate } } # Correct for number of tests p.value_matr.adjust &lt;- p.adjust(p.value_matr, method = &quot;fdr&quot;) dim(p.value_matr.adjust) &lt;- dim(p.value_matr) dimnames(p.value_matr.adjust) &lt;- list(colnames(X_eigengenes), colnames(Y_eigengenes)) # Add significance level. # One star means a p-value of less than 0.05; Two stars is less than 0.01, and three, is less than 0.001. signif_matrix &lt;- rep(&quot;&quot;, length(p.value_matr)) three_star &lt;- which( p.value_matr &lt;= 0.001) signif_matrix[three_star] &lt;- &quot;***&quot; two_star &lt;- which((p.value_matr &lt;= 0.01) &amp; (p.value_matr &gt; 0.001)) signif_matrix[two_star] &lt;- &quot;**&quot; one_star &lt;- which((p.value_matr &lt;= 0.05) &amp; (p.value_matr &gt; 0.01)) signif_matrix[one_star] &lt;- &quot;*&quot; dim(signif_matrix) = dim(p.value_matr) # Give textMatrix the correct dimensions # Collect all results into a list. Y_corr_X &lt;- list(p_value = p.value_matr, p_value_adj = p.value_matr.adjust, signif_matrix = signif_matrix, correlation = corr.value_matr) rm(p.value_matr, p.value_matr.adjust, signif_matrix, corr.value_matr) heatmap_colors &lt;- colorRampPalette(rev(RColorBrewer::brewer.pal(n = 6, name =&quot;RdBu&quot;)))(51) pheatmap::pheatmap(Y_corr_X$correlation, color = heatmap_colors, treeheight_col = 0, treeheight_row = 0, # will be shown on the transcriptomics ME heatmap cluster_rows = X_ME_dendro, cutree_rows = 4, display_numbers = Y_corr_X$signif_matrix, fontsize_number = 10, breaks = seq(from = -1, to = 1, length.out = 51), silent = F, show_rownames = F, labels_row = paste0(&quot;mg&quot;, rownames(Y_corr_X$correlation)), labels_col = paste0(&quot;mg&quot;, colnames(Y_corr_X$correlation)), main = &quot;EigenOTUs&quot;) -&gt; Y_corr_X_plot ## Combine heatmaps cowplot::plot_grid(Y_corr_X_plot$gtable, X_plot$gtable, ncol = 2, rel_widths = c(dim(Y_eigengenes)[2]/3, dim(X_eigengenes)[1]/9), align = &quot;h&quot;) + ggplot2::theme(plot.margin = ggplot2::unit(c(3,0,2.5,1), &quot;cm&quot;)) 2.6.3 Visualization network The strong correlation between mgME3 and mbME1 is the modules of interest, and we wondered if they contain those bacteria and metabolites, which ara published in the existing literature, or if there is a potential mining value. So we visualize network in mgME3 and mbME1 (In the practical application，find the module you are interested in for visualization) Visualize mgME3 #load(file = &quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/GVHD/bookdown_GVHD/result/modules.mgs-block.1.RData&quot;) load(file = &quot;./result/modules.mgs-block.1.RData&quot;) # The TOM is saved as a dist object and needs to be converted to a matrix TOM &lt;- as.matrix(TOM) # Add OTU names to the TOM matrix. It is symmetrical so rownames = colnames rownames(TOM) &lt;- colnames(TOM) &lt;- names(modules.mgs$colors) ## Which taxonomic level should the graph be colored with in addition to modules? selected_taxa &lt;- &quot;Genus&quot; Convert module labels and taxonomy to hex colors (MGS) taxonomy_info &lt;- taxa_table %&gt;% rownames_to_column(var = &quot;OTU_name&quot;) %&gt;% dplyr::select(&quot;OTU_name&quot;, selected_taxa) %&gt;% mutate_all(.funs = list(as.character)) module_info &lt;- modules.mgs$colors %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;OTU_name&quot;) %&gt;% dplyr::rename(Module = &quot;.&quot;) %&gt;% filter(Module == 3) # selected module, here is ME3 TOM &lt;- TOM[module_info$OTU_name, module_info$OTU_name] graph_info &lt;- left_join(module_info, taxonomy_info, by = &quot;OTU_name&quot;) # Converts R-colors to hex colors color2hex &lt;- function(x){ x &lt;- col2rgb(x) rgb(x[1,], x[2,], x[3,], maxColorValue = 255) } # Add specific colors to the taxa taxa_colors &lt;- graph_info %&gt;% dplyr::select(selected_taxa) %&gt;% unique() %&gt;% mutate(tax_color = colorRampPalette(RColorBrewer::brewer.pal(8, &quot;Accent&quot;))(nrow(.))) graph_info_colors &lt;- left_join(graph_info, taxa_colors) %&gt;% mutate(module_color = WGCNA::labels2colors(Module)) %&gt;% mutate(module_color = color2hex(module_color)) %&gt;% mutate(module_color = paste0(module_color,70)) ## Joining, by = &quot;Genus&quot; ## If all lines are too thick, reduce the strength (between 0 and 1). ## The lower the number the weaker the lines. strength_adjust = 1 Construct taxa network with igraph g &lt;- graph.adjacency(TOM, mode=&quot;undirected&quot;, weighted= TRUE) #~https://stackoverflow.com/questions/28366329/how-to-scale-edge-colors-igraph igraph::delete.edges(g, which(E(g)$weight &lt;1)) ## IGRAPH 9e641dc UNW- 12 0 -- ## + attr: name (v/c), weight (e/n) ## + edges from 9e641dc (vertex names): E(g)$width &lt;- E(g)$weight*strength_adjust + min(E(g)$weight) E(g)$color &lt;- &quot;red&quot; set.seed(231) # Ensures the same layout given the same data. l &lt;- layout_with_fr(g, weights = E(g)$weight) # Order graph_info_colors by the graph graph_info_colors &lt;- graph_info_colors[which(graph_info_colors$OTU_name %in% V(g)$name),] # Ensure that the names are in the same order if(all(V(g)$name == graph_info_colors$OTU_name)){cat(&quot;\\nOTU names match&quot;)} ## ## OTU names match # Add square shapes to hub OTUs V(g)$shape &lt;- ifelse(V(g)$name %in% hubs.mgs[-1], &quot;square&quot;, &quot;circle&quot;) #-1 means dont use module 0 # OTUs in modules have larger nodes V(g)$size &lt;- ifelse(graph_info_colors$Module != 0, 10, 5) # And larger text V(g)$label.cex &lt;- ifelse(graph_info_colors$Module != 0, 0.8, 0.4) # Remove everything but the number to increase readability V(g)$name = sub(&quot;OTU_&quot;, &quot;&quot;, graph_info_colors$OTU_name) Find distinct entires for the plot legends module_labels &lt;- graph_info_colors %&gt;% dplyr::select(Module, module_color) %&gt;% distinct() %&gt;% arrange(Module) tax_labels &lt;- graph_info_colors %&gt;% dplyr::select(selected_taxa, tax_color) %&gt;% distinct() Plot the graphs, leftmost is colored by module, rightmost is colored by taxonomic classification par(mfrow = c(1,2)) par(mar = c(0,0,0,0)) # plot(g, layout = l, vertex.color = graph_info_colors$module_color) # # legend(&quot;topleft&quot;, legend = paste0(&quot;mM&quot;, 0:(nrow(module_labels)-1)), fill=module_labels$module_color) # legend(&quot;topleft&quot;, legend = paste0(&quot;mgsM&quot;, 3), fill=module_labels$module_color) plot(g, layout = l, vertex.color = graph_info_colors$tax_color) legend(&quot;topleft&quot;, legend = tax_labels$Genus, fill=tax_labels$tax_color) par(mfrow = c(1,1)) Visualize mbME1 #load(file = &quot;/share/projects/Analytics/analytics/MultiOmics/tools/WGCNA/test/GVHD/bookdown_GVHD/result/module.metabolites-block.1.RData&quot;) load(file = &quot;./result/module.metabolites-block.1.RData&quot;) # The TOM is saved as a dist object and needs to be converted to a matrix TOM &lt;- as.matrix(TOM) # Add OTU names to the TOM matrix. It is symmetrical so rownames = colnames rownames(TOM) &lt;- colnames(TOM) &lt;- names(modules.metabolites$colors) ## Which metabolic level should the graph be colored with in addition to modules? selected_taxa &lt;- &quot;Class.II&quot; Convert module labels and taxonomy to hex colors taxonomy_info &lt;- metabolites_level %&gt;% rownames_to_column(var = &quot;mbs_name&quot;) %&gt;% dplyr::select(&quot;mbs_name&quot;, selected_taxa) %&gt;% mutate_all(.funs = list(as.character)) module_info &lt;- modules.metabolites$colors %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;mbs_name&quot;) %&gt;% dplyr::rename(Module = &quot;.&quot;) %&gt;% filter(Module == 1) # selected module, here is ME1 TOM &lt;- TOM[module_info$mbs_name, module_info$mbs_name] graph_info &lt;- left_join(module_info, taxonomy_info, by = &quot;mbs_name&quot;) # Converts R-colors to hex colors color2hex &lt;- function(x){ x &lt;- col2rgb(x) rgb(x[1,], x[2,], x[3,], maxColorValue = 255) } # Add specific colors to the taxa taxa_colors &lt;- graph_info %&gt;% dplyr::select(selected_taxa) %&gt;% unique() %&gt;% mutate(tax_color = colorRampPalette(RColorBrewer::brewer.pal(8, &quot;Accent&quot;))(nrow(.))) graph_info_colors &lt;- left_join(graph_info, taxa_colors) %&gt;% mutate(module_color = WGCNA::labels2colors(Module)) %&gt;% mutate(module_color = color2hex(module_color)) %&gt;% mutate(module_color = paste0(module_color,70)) ## Joining, by = &quot;Class.II&quot; ## If all lines are too thick, reduce the strength (between 0 and 1). ## The lower the number the weaker the lines. strength_adjust = 0.2 Construct metabolites network with igraph g &lt;- graph.adjacency(TOM, mode=&quot;undirected&quot;, weighted= TRUE) #~https://stackoverflow.com/questions/28366329/how-to-scale-edge-colors-igraph igraph::delete.edges(g, which(E(g)$weight &lt;1)) ## IGRAPH c2be798 UNW- 54 0 -- ## + attr: name (v/c), weight (e/n) ## + edges from c2be798 (vertex names): E(g)$width &lt;- E(g)$weight*strength_adjust + min(E(g)$weight) E(g)$color &lt;- &quot;red&quot; set.seed(231) # Ensures the same layout given the same data. l &lt;- layout_with_fr(g, weights = E(g)$weight) # Order graph_info_colors by the graph graph_info_colors &lt;- graph_info_colors[which(graph_info_colors$mbs_name %in% V(g)$name),] # Ensure that the names are in the same order if(all(V(g)$name == graph_info_colors$mbs_name)){cat(&quot;\\nmbs names match&quot;)} ## ## mbs names match # Add square shapes to hub OTUs V(g)$shape &lt;- ifelse(V(g)$name %in% hubs.metabolites[-1], &quot;square&quot;, &quot;circle&quot;) #-1 means dont use module 0 # OTUs in modules have larger nodes V(g)$size &lt;- ifelse(graph_info_colors$Module != 0, 10, 5) # And larger text V(g)$label.cex &lt;- ifelse(graph_info_colors$Module != 0, 0.8, 0.4) # Remove everything but the number to increase readability V(g)$name = sub(&quot;mbs_&quot;, &quot;&quot;, graph_info_colors$mbs_name) Find distinct entires for the plot legends metabolites module_labels &lt;- graph_info_colors %&gt;% dplyr::select(Module, module_color) %&gt;% distinct() %&gt;% arrange(Module) tax_labels &lt;- graph_info_colors %&gt;% dplyr::select(selected_taxa, tax_color) %&gt;% distinct() Plot the graphs, leftmost is colored by module, rightmost is colored by taxonomic classification par(mfrow = c(1,2)) par(mar = c(0,0,0,0)) # plot(g, layout = l, vertex.color = graph_info_colors$module_color) # # legend(&quot;topleft&quot;, legend = paste0(&quot;mM&quot;, 0:(nrow(module_labels)-1)), fill=module_labels$module_color) # legend(&quot;topleft&quot;, legend = paste0(&quot;mbM&quot;, 1), fill=module_labels$module_color) plot(g, layout = l, vertex.color = graph_info_colors$tax_color) legend(&quot;topright&quot;, legend = tax_labels$Class.II, fill=tax_labels$tax_color) par(mfrow = c(1,1)) 2.7 Session Info devtools::session_info() ## ─ Session info ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.3 (2020-02-29) ## os Ubuntu 16.04.7 LTS ## system x86_64, linux-gnu ## ui RStudio ## language (EN) ## collate en_IN.UTF-8 ## ctype en_IN.UTF-8 ## tz Asia/Hong_Kong ## date 2022-09-15 ## rstudio 1.1.419 (server) ## pandoc 2.7.3 @ /usr/bin/ (via rmarkdown) ## ## ─ Packages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## ! package * version date (UTC) lib source ## abind 1.4-5 2016-07-21 [1] CRAN (R 3.6.3) ## ade4 1.7-17 2021-06-17 [1] CRAN (R 3.6.3) ## AnnotationDbi 1.58.0 2022-04-26 [1] Bioconductor ## ape 5.5 2021-04-25 [1] CRAN (R 3.6.3) ## assertthat 0.2.1 2019-03-21 [2] CRAN (R 3.6.3) ## backports 1.4.1 2021-12-13 [1] CRAN (R 3.6.3) ## base64enc 0.1-3 2015-07-28 [2] CRAN (R 3.6.3) ## Biobase * 2.46.0 2019-10-29 [2] Bioconductor ## BiocGenerics * 0.32.0 2019-10-29 [2] Bioconductor ## BiocParallel * 1.20.1 2019-12-21 [2] Bioconductor ## biomformat 1.14.0 2019-10-29 [1] Bioconductor ## Biostrings 2.54.0 2019-10-29 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] CRAN (R 3.6.3) ## bit64 4.0.5 2020-08-30 [1] CRAN (R 3.6.3) ## bitops 1.0-7 2021-04-24 [1] CRAN (R 3.6.3) ## blob 1.2.2 2021-07-23 [1] CRAN (R 3.6.3) ## bookdown 0.24 2021-09-02 [1] CRAN (R 3.6.3) ## brio 1.1.3 2021-11-30 [2] CRAN (R 3.6.3) ## broom 0.7.12 2022-01-28 [1] CRAN (R 3.6.3) ## bslib 0.3.1 2021-10-06 [1] CRAN (R 3.6.3) ## cachem 1.0.5 2021-05-15 [1] CRAN (R 3.6.3) ## callr 3.7.0 2021-04-20 [2] CRAN (R 3.6.3) ## caTools 1.18.2 2021-03-28 [1] CRAN (R 3.6.3) ## cccd 1.6 2022-04-08 [1] CRAN (R 3.6.3) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 3.6.3) ## checkmate 2.0.0 2020-02-06 [1] CRAN (R 3.6.3) ## cli 3.1.0 2021-10-27 [1] CRAN (R 3.6.3) ## cluster 2.1.0 2019-06-19 [2] CRAN (R 3.6.3) ## codetools 0.2-16 2018-12-24 [2] CRAN (R 3.6.3) ## colorspace 2.0-2 2021-06-24 [1] CRAN (R 3.6.3) ## corpcor 1.6.10 2021-09-16 [2] CRAN (R 3.6.3) ## cowplot 1.1.1 2020-12-30 [1] CRAN (R 3.6.3) ## crayon 1.5.0 2022-02-14 [1] CRAN (R 3.6.3) ## crosstalk 1.2.0 2021-11-04 [2] CRAN (R 3.6.3) ## data.table 1.14.0 2021-02-21 [1] CRAN (R 3.6.3) ## DBI 1.1.1 2021-01-15 [1] CRAN (R 3.6.3) ## dbplyr 2.1.1 2021-04-06 [1] CRAN (R 3.6.3) ## DelayedArray * 0.12.3 2020-04-09 [2] Bioconductor ## deldir 1.0-6 2021-10-23 [2] CRAN (R 3.6.3) ## desc 1.4.1 2022-03-06 [2] CRAN (R 3.6.3) ## devtools 2.4.3 2021-11-30 [1] CRAN (R 3.6.3) ## digest 0.6.29 2021-12-01 [1] CRAN (R 3.6.3) ## doParallel 1.0.17 2022-02-07 [2] CRAN (R 3.6.3) ## doSNOW 1.0.20 2022-02-04 [1] CRAN (R 3.6.3) ## dplyr * 1.0.6 2021-05-05 [1] CRAN (R 3.6.3) ## DT * 0.23 2022-05-10 [2] CRAN (R 3.6.3) ## dynamicTreeCut * 1.63-1 2016-03-11 [1] CRAN (R 3.6.3) ## ellipsis 0.3.2 2021-04-29 [1] CRAN (R 3.6.3) ## evaluate 0.15 2022-02-18 [2] CRAN (R 3.6.3) ## fansi 1.0.2 2022-01-14 [1] CRAN (R 3.6.3) ## farver 2.1.0 2021-02-28 [2] CRAN (R 3.6.3) ## fastcluster * 1.2.3 2021-05-24 [1] CRAN (R 3.6.3) ## fastmap 1.1.0 2021-01-25 [1] CRAN (R 3.6.3) ## fdrtool 1.2.17 2021-11-13 [1] CRAN (R 3.6.3) ## filematrix 1.3 2018-02-27 [1] CRAN (R 3.6.3) ## FNN 1.1.3 2019-02-15 [1] CRAN (R 3.6.3) ## forcats * 0.5.1 2021-01-27 [1] CRAN (R 3.6.3) ## foreach 1.5.2 2022-02-02 [2] CRAN (R 3.6.3) ## foreign 0.8-75 2020-01-20 [2] CRAN (R 3.6.3) ## Formula 1.2-4 2020-10-16 [1] CRAN (R 3.6.3) ## fs 1.5.2 2021-12-08 [1] CRAN (R 3.6.3) ## generics 0.1.2 2022-01-31 [1] CRAN (R 3.6.3) ## GenomeInfoDb * 1.22.1 2020-03-27 [2] Bioconductor ## GenomeInfoDbData 1.2.2 2020-08-24 [2] Bioconductor ## GenomicRanges * 1.38.0 2019-10-29 [2] Bioconductor ## ggforce 0.3.3 2021-03-05 [1] CRAN (R 3.6.3) ## ggplot2 * 3.3.5 2021-06-25 [1] CRAN (R 3.6.3) ## ggraph * 2.0.5 2021-02-23 [1] CRAN (R 3.6.3) ## ggrepel 0.9.1 2021-01-15 [2] CRAN (R 3.6.3) ## glasso 1.11 2019-10-01 [1] CRAN (R 3.6.3) ## glmnet 4.1-2 2021-06-24 [1] CRAN (R 3.6.3) ## glue 1.6.1 2022-01-22 [1] CRAN (R 3.6.3) ## GO.db 3.15.0 2022-09-14 [1] Bioconductor ## gplots 3.1.1 2020-11-28 [1] CRAN (R 3.6.3) ## graphlayouts 0.7.2 2021-11-21 [1] CRAN (R 3.6.3) ## gridExtra 2.3 2017-09-09 [2] CRAN (R 3.6.3) ## gtable 0.3.0 2019-03-25 [2] CRAN (R 3.6.3) ## gtools 3.9.2 2021-06-06 [1] CRAN (R 3.6.3) ## haven 2.4.1 2021-04-23 [1] CRAN (R 3.6.3) ## highr 0.9 2021-04-16 [1] CRAN (R 3.6.3) ## Hmisc 4.5-0 2021-02-28 [1] CRAN (R 3.6.3) ## hms 1.1.1 2021-09-26 [1] CRAN (R 3.6.3) ## htmlTable 2.3.0 2021-10-12 [1] CRAN (R 3.6.3) ## htmltools 0.5.2 2021-08-25 [1] CRAN (R 3.6.3) ## htmlwidgets 1.5.4 2021-09-08 [2] CRAN (R 3.6.3) ## httr 1.4.3 2022-05-04 [2] CRAN (R 3.6.3) ## huge 1.3.5 2021-06-30 [1] CRAN (R 3.6.3) ## igraph * 1.3.1 2022-04-20 [2] CRAN (R 3.6.3) ## IHW 1.14.0 2019-10-29 [1] Bioconductor ## impute 1.60.0 2019-10-29 [2] Bioconductor ## IRanges * 2.20.2 2020-01-13 [2] Bioconductor ## irlba 2.3.4 2021-12-03 [1] CRAN (R 3.6.3) ## iterators 1.0.14 2022-02-05 [2] CRAN (R 3.6.3) ## jpeg 0.1-9 2021-07-24 [1] CRAN (R 3.6.3) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 3.6.3) ## jsonlite 1.8.0 2022-02-22 [2] CRAN (R 3.6.3) ## KEGGREST 1.26.1 2019-11-06 [1] Bioconductor ## KernSmooth 2.23-16 2019-10-15 [2] CRAN (R 3.6.3) ## knitr 1.36 2021-09-29 [1] CRAN (R 3.6.3) ## labeling 0.4.2 2020-10-20 [2] CRAN (R 3.6.3) ## lattice 0.20-38 2018-11-04 [2] CRAN (R 3.6.3) ## latticeExtra 0.6-29 2019-12-19 [1] CRAN (R 3.6.3) ## lavaan 0.6-12 2022-07-04 [1] CRAN (R 3.6.3) ## lazyeval 0.2.2 2019-03-15 [2] CRAN (R 3.6.3) ## lifecycle 1.0.1 2021-09-24 [1] CRAN (R 3.6.3) ## limma 3.42.2 2020-02-03 [2] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] CRAN (R 3.6.3) ## lpsymphony 1.14.0 2019-10-29 [1] Bioconductor (R 3.6.3) ## lubridate 1.7.10 2021-02-26 [1] CRAN (R 3.6.3) ## magrittr 2.0.2 2022-01-26 [1] CRAN (R 3.6.3) ## MASS 7.3-54 2021-05-03 [1] CRAN (R 3.6.3) ## Matrix 1.3-4 2021-06-01 [1] CRAN (R 3.6.3) ## matrixStats * 0.60.0 2021-07-26 [1] CRAN (R 3.6.3) ## memoise 2.0.1 2021-11-26 [2] CRAN (R 3.6.3) ## metagenomeSeq 1.28.2 2020-02-03 [1] Bioconductor ## mgcv 1.8-31 2019-11-09 [2] CRAN (R 3.6.3) ## mixedCCA 1.6.2 2022-09-15 [1] Github (irinagain/mixedCCA@4c2b63f) ## mnormt 2.0.2 2020-09-01 [1] CRAN (R 3.6.3) ## modelr 0.1.8 2020-05-19 [1] CRAN (R 3.6.3) ## multtest 2.42.0 2019-10-29 [2] Bioconductor ## munsell 0.5.0 2018-06-12 [2] CRAN (R 3.6.3) ## mvtnorm 1.1-3 2021-10-08 [1] CRAN (R 3.6.3) ## NADA 1.6-1.1 2020-03-22 [1] CRAN (R 3.6.3) ## NetCoMi * 1.0.3 2022-09-15 [1] Github (stefpeschel/NetCoMi@1260971) ## nlme 3.1-144 2020-02-06 [2] CRAN (R 3.6.3) ## nnet 7.3-12 2016-02-02 [2] CRAN (R 3.6.3) ## pbapply 1.5-0 2021-09-16 [1] CRAN (R 3.6.3) ## pbivnorm 0.6.0 2015-01-23 [1] CRAN (R 3.6.3) ## pcaPP 1.9-74 2021-04-23 [1] CRAN (R 3.6.3) ## permute 0.9-5 2019-03-12 [1] CRAN (R 3.6.3) ## pheatmap 1.0.12 2019-01-04 [1] CRAN (R 3.6.3) ## phyloseq * 1.30.0 2019-10-29 [1] Bioconductor ## pillar 1.7.0 2022-02-01 [1] CRAN (R 3.6.3) ## pkgbuild 1.3.1 2021-12-20 [2] CRAN (R 3.6.3) ## pkgconfig 2.0.3 2019-09-22 [2] CRAN (R 3.6.3) ## pkgload 1.2.4 2021-11-30 [2] CRAN (R 3.6.3) ## plotly * 4.10.0 2021-10-09 [1] CRAN (R 3.6.3) ## plyr 1.8.7 2022-03-24 [2] CRAN (R 3.6.3) ## png 0.1-7 2013-12-03 [1] CRAN (R 3.6.3) ## polyclip 1.10-0 2019-03-14 [1] CRAN (R 3.6.3) ## preprocessCore 1.48.0 2019-10-29 [2] Bioconductor ## prettyunits 1.1.1 2020-01-24 [2] CRAN (R 3.6.3) ## processx 3.5.3 2022-03-25 [2] CRAN (R 3.6.3) ## proxy 0.4-26 2021-06-07 [2] CRAN (R 3.6.3) ## ps 1.7.0 2022-04-23 [2] CRAN (R 3.6.3) ## psych 2.1.9 2021-09-22 [1] CRAN (R 3.6.3) ## pulsar 0.3.7 2020-08-07 [1] CRAN (R 3.6.3) ## purrr * 0.3.4 2020-04-17 [2] CRAN (R 3.6.3) ## qgraph 1.9.2 2022-03-04 [1] CRAN (R 3.6.3) ## R6 2.5.1 2021-08-19 [1] CRAN (R 3.6.3) ## rbibutils 2.2.5 2021-12-04 [1] CRAN (R 3.6.3) ## RColorBrewer 1.1-3 2022-04-03 [2] CRAN (R 3.6.3) ## Rcpp 1.0.7 2021-07-07 [1] CRAN (R 3.6.3) ## RCurl 1.98-1.6 2022-02-08 [2] CRAN (R 3.6.3) ## Rdpack 2.1.2 2021-06-01 [1] CRAN (R 3.6.3) ## readr * 2.0.0 2021-07-20 [1] CRAN (R 3.6.3) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 3.6.3) ## remotes 2.4.2 2021-11-30 [1] CRAN (R 3.6.3) ## reprex 2.0.1 2021-08-05 [1] CRAN (R 3.6.3) ## reshape2 1.4.4 2020-04-09 [2] CRAN (R 3.6.3) ## rhdf5 2.30.1 2019-11-26 [1] Bioconductor ## Rhdf5lib 1.8.0 2019-10-29 [1] Bioconductor ## rJava 1.0-5 2021-09-24 [1] CRAN (R 3.6.3) ## R rlang 1.0.2 &lt;NA&gt; [2] &lt;NA&gt; ## rmarkdown 2.11 2021-09-14 [1] CRAN (R 3.6.3) ## rootSolve 1.8.2.3 2021-09-29 [1] CRAN (R 3.6.3) ## rpart 4.1-15 2019-04-12 [2] CRAN (R 3.6.3) ## rprojroot 2.0.2 2020-11-15 [1] CRAN (R 3.6.3) ## RSQLite 2.2.7 2021-04-22 [1] CRAN (R 3.6.3) ## rstudioapi 0.13 2020-11-12 [2] CRAN (R 3.6.3) ## rvest 1.0.2 2021-10-16 [1] CRAN (R 3.6.3) ## S4Vectors * 0.24.4 2020-04-09 [2] Bioconductor ## sass 0.4.0 2021-05-12 [1] CRAN (R 3.6.3) ## scales 1.2.0 2022-04-13 [2] CRAN (R 3.6.3) ## sessioninfo 1.2.2 2021-12-06 [2] CRAN (R 3.6.3) ## shape 1.4.6 2021-05-19 [1] CRAN (R 3.6.3) ## slam 0.1-49 2021-11-17 [1] CRAN (R 3.6.3) ## snow 0.4-4 2021-10-27 [2] CRAN (R 3.6.3) ## SpiecEasi * 1.1.2 2022-04-19 [1] Github (zdk123/SpiecEasi@c463727) ## SPRING * 1.0.4 2022-09-15 [1] Github (GraceYoon/SPRING@3d641a4) ## stringi 1.7.4 2021-08-25 [1] CRAN (R 3.6.3) ## stringr * 1.4.0 2019-02-10 [2] CRAN (R 3.6.3) ## SummarizedExperiment * 1.16.1 2019-12-19 [2] Bioconductor ## survival 3.1-8 2019-12-03 [2] CRAN (R 3.6.3) ## testthat 3.1.4 2022-04-26 [2] CRAN (R 3.6.3) ## tibble * 3.1.6 2021-11-07 [1] CRAN (R 3.6.3) ## tidygraph 1.2.0 2020-05-12 [1] CRAN (R 3.6.3) ## tidyr * 1.2.0 2022-02-01 [1] CRAN (R 3.6.3) ## tidyselect 1.1.1 2021-04-30 [1] CRAN (R 3.6.3) ## tidyverse * 1.3.1 2021-04-15 [1] CRAN (R 3.6.3) ## tmvnsim 1.0-2 2016-12-15 [1] CRAN (R 3.6.3) ## truncnorm 1.0-8 2018-02-27 [1] CRAN (R 3.6.3) ## tweenr 1.0.2 2021-03-23 [1] CRAN (R 3.6.3) ## tzdb 0.2.0 2021-10-27 [1] CRAN (R 3.6.3) ## usethis 2.1.6 2022-05-25 [2] CRAN (R 3.6.3) ## utf8 1.2.2 2021-07-24 [1] CRAN (R 3.6.3) ## vctrs 0.3.8 2021-04-29 [1] CRAN (R 3.6.3) ## vegan 2.5-7 2020-11-28 [1] CRAN (R 3.6.3) ## VGAM 1.1-6 2022-02-14 [1] CRAN (R 3.6.3) ## viridis 0.6.2 2021-10-13 [1] CRAN (R 3.6.3) ## viridisLite 0.4.0 2021-04-13 [2] CRAN (R 3.6.3) ## WGCNA * 1.71 2022-04-22 [1] CRAN (R 3.6.3) ## withr 2.4.3 2021-11-30 [1] CRAN (R 3.6.3) ## Wrench 1.4.0 2019-10-29 [1] Bioconductor ## xfun 0.23 2021-05-15 [1] CRAN (R 3.6.3) ## xlsx * 0.6.5 2020-11-10 [1] CRAN (R 3.6.3) ## xlsxjars 0.6.1 2014-08-22 [1] CRAN (R 3.6.3) ## xml2 1.3.3 2021-11-30 [2] CRAN (R 3.6.3) ## XVector 0.26.0 2019-10-29 [2] Bioconductor ## yaml 2.2.2 2022-01-25 [1] CRAN (R 3.6.3) ## zCompositions 1.3.4 2020-03-04 [1] CRAN (R 3.6.3) ## zlibbioc 1.32.0 2019-10-29 [2] Bioconductor ## ## [1] /share/home/tongbangzhuo/R/x86_64-pc-linux-gnu-library/3.6 ## [2] /opt/R-3.6.3/lib/R/library ## ## R ── Package was removed from disk. ## ## ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── "],["halla.html", "Chapter 3 HAllA 3.1 Introduction 3.2 Run HALLA 3.3 Result of HALLA", " Chapter 3 HAllA For any questions about this chapter, please contact zhaoyifan (zhaoyifan@xbiome.com) 3.1 Introduction HAllA (Hierarchical All-against-All association) 是一个针对多维度、异质型数据集的多重关联分析工具。可用于连续型/分类型数值数据，且在同质型（homogeneous）数据集（所有数值皆相同类型，例如：RNA-seq 基因表現）与异质型（heterogeneous）数据集（不同单位或类型的数值，例如：病患临床指标）皆可高效分析。在目前微生物研究中，HAllA是一個常用于微生物组-代谢、微生物组-临床指标、微生物组-转录组（基因表現、miRNA、GO） 等关联分析的重要工具。 HAllA workflow 3.1.1 Available pairwise distance metrics spearman (default for continuous data) pearson mi (A set of properties of Mutual Information result from definition. default for mixed/categorical data) nmi (Normalized Mutual Information) xicor (Chatterjee correlation, uses rank differences to assess the degree to which one variable is a measurable function of another，适用于离散、非线性关系数据) dcor (measures not necessarily linear dependency of two random variables with possibly different dimensions) HAllA correlation methods 3.1.2 Running procedures 3.1.2.1 step1 The pairwise similarity matrix between all features in X and Y is computed with a specified similarity measure, such as Spearman correlation and normalized mutual information (NMI). This step then generates the p-value and q-value tables. Note that for handling heterogeneous data, all continuous features are first discretized into bins using a specified binning method. 3.1.2.2 step2 Hierarchical clustering on the features in each dataset is performed using the converted similarity measure used in step 1. It produces a tree for each dataset. 3.1.2.3 step3 Finding densely-associated blocks (pseudocode): def find_densely_associated_blocks(x, y): x_features = all features in x y_features = all features in y if is_densely_associated(x_features, y_features): report block and terminate else: # bifurcate one according to Gini impurities of the splits x_branches, y_branches = bifurcate_one_of(x, y) if both x and y are leaves: terminate for each x_branch and y_branch in x_branches and y_branches: find_densely_associated_blocks(x_branch, y_branch) initial function call: find_densely_associated_blocks(X_root, Y_root) For example, given two datasets of X (features: X1, X2, X3, X4, X5) and Y (features: Y1, Y2, Y3, Y4) both hierarchically clustered in X tree and Y tree, the algorithm first evaluates the roots of both trees and checks if the block consisting of all features of X and Y are densely-associated (if %significance (%reject) &gt;= (1 - FNR)%). If the block is not densely-associated, the algorithm would bifurcate one of the trees. It would pick one of: ·[X1 X2][X3 X4 X5] &gt;&lt; [Y1 Y2 Y3 Y4] or ·[X1 X2 X3 X4 X5] &gt;&lt; [Y1 Y2 Y3][Y4] based on the Gini impurity of the splits (pick the split that produces a lower weighted Gini impurity), Once it picks the split with the lower impurity (let’s say the first split), it will iteratively evaluate the branches: ·find densely-associated blocks in [X1 X2] vs [Y1 Y2 Y3 Y4], and ·find densely-associated blocks in [X3 X4 X5] vs [Y1 Y2 Y3 Y4] and keep going until it terminates. 3.2 Run HALLA Run HALLA on remote server conda activate /opt/conda/envs/Halla halla -h halla -x table_X -y table_Y -m correlation_methods -o output_file --fdr_alpha adjustP --fdr_method FDR_methods 3.3 Result of HALLA HAllA result after WGCNA Correlation with modules "],["netcomi.html", "Chapter 4 NetCoMi 4.1 Introduction 4.2 Environment Setup 4.3 Loading data 4.4 Data curation 4.5 Associations Among Features 4.6 Dissimilarity-based Networks 4.7 Network comparison 4.8 Session info", " Chapter 4 NetCoMi For any questions about this chapter, please contact zouhua (zouhua@xbiome.com) 4.1 Introduction Estimating microbial association networks from high-throughput sequencing data is a common exploratory data analysis approach aiming at understanding the complex interplay of microbial communities in their natural habitat. Statistical network estimation workflows comprise several analysis steps, including methods for zero handling, data normalization and computing microbial associations. Since microbial interactions are likely to change between conditions, e.g. between healthy individuals and patients, identifying network differences between groups is often an integral secondary analysis step. NetCoMi (Network Construction and Comparison for Microbiome Data) (Peschel et al. 2021) provides functionality for constructing, analyzing, and comparing networks suitable for the application on microbial compositional data. Below we listed all adjustable parameters in NetCoMi. Information is from NetCoMi github. 4.1.1 Association measures Pearson coefficient (cor() from stats package) Spearman coefficient (cor() from stats package) Biweight Midcorrelation bicor() from WGCNA package SparCC (sparcc() from SpiecEasi package) CCLasso (R code on GitHub) CCREPE (ccrepepackage) SpiecEasi (SpiecEasi package) SPRING (SPRING package) gCoda (R code on GitHub) propr (propr package) 4.1.2 Dissimilarity measures Euclidean distance (vegdist() from vegan package) Bray-Curtis dissimilarity (vegdist() from vegan package) Kullback-Leibler divergence (KLD) (KLD() from LaplacesDemon package) Jeffrey divergence (own code using KLD() from LaplacesDemon package) Jensen-Shannon divergence (own code using KLD() from LaplacesDemon package) Compositional KLD (own implementation following [Martín-Fernández et al., 1999]) Aitchison distance (vegdist() and clr() from SpiecEasi package) 4.1.3 Methods for zero replacement Adding a predefined pseudo count Multiplicative replacement (multRepl from zCompositions package) Modified EM alr-algorithm (lrEM from zCompositions package) Bayesian-multiplicative replacement (cmultRepl from zCompositions package) 4.1.4 Normalization methods Total Sum Scaling (TSS) (own implementation) Cumulative Sum Scaling (CSS) (cumNormMat from metagenomeSeq package) Common Sum Scaling (COM) (own implementation) Rarefying (rrarefy from vegan package) Variance Stabilizing Transformation (VST) (varianceStabilizingTransformation from DESeq2 package) Centered log-ratio (clr) transformation (clr from SpiecEasi package)) TSS, CSS, COM, VST, and the clr transformation are described in [Badri et al., 2020]. 4.2 Environment Setup knitr::opts_chunk$set(warning = F) library(dplyr) library(tibble) library(ggplot2) library(plotly) library(SummarizedExperiment) library(ggraph) library(NetCoMi) library(SPRING) library(SpiecEasi) options(stringsAsFactors = F) options(future.globals.maxSize = 1000 * 1024^2) 4.3 Loading data The input data sets are from the previous chapter. se_filter &lt;- readRDS(&quot;./dataset/POMA/se_filter.RDS&quot;) 4.4 Data curation features_tab &lt;- SummarizedExperiment::assay(se_filter) %&gt;% t() features_tab[is.na(features_tab)] &lt;- 0 head(features_tab) ## M_52603 M_19130 M_39270 M_35186 M_34214 M_49617 M_52710 M_53189 M_34419 M_36600 M_54885 M_32350 M_55041 M_48258 M_35628 M_33230 M_52462 ## P101001 94392176 25632184 959249.2 8141286 8284910 381540.1 47739292 392911.0 306346432 9887348 298886.1 627613.7 3655240 181136336 6548460 19098412 486910976 ## P101004 115155104 25106562 785895.0 4303854 7923489 588488.2 43678784 300383.9 263333424 9703074 356274.3 339586.8 1637351 115752200 3455001 10641834 380887616 ## P101007 79582632 31371314 1903592.4 7129884 9211485 464548.8 53975068 539361.5 191261648 6431966 393623.0 662555.6 7284474 102036920 3640571 14977371 515795264 ## P101009 118408760 27787270 863701.9 5394354 8559147 497342.0 47619564 487186.2 232171184 11914472 599783.6 492430.9 3065707 118663320 5087503 13575508 390977568 ## P101010 92508664 26685844 1177860.8 6270727 7623603 457409.1 61906028 236719.5 183104336 9366287 280123.8 373484.2 2493687 154183360 5244878 19464998 478479936 ## P101011 94076424 27780988 638271.3 4292087 6074633 238781.8 40534280 279118.7 164623888 6003700 349482.3 608671.7 2653816 76137216 2238570 8797510 420938976 ## M_52464 M_52454 M_52610 M_42446 M_52461 M_52616 M_33955 M_35631 M_42450 M_52447 M_52449 M_52452 M_52438 M_33961 M_42398 M_47403 M_57547 ## P101001 6794782 274026048 206279104 712253440 486655872 12365879 448634784 4035864 358896736 30252208 43173148 510461472 181406848 191147264 6137137 209255.5 169297.7 ## P101004 4090405 282066016 253920496 807180352 439253152 10655923 413690720 3446139 282910752 19424238 30030992 573170816 122556968 166379712 5143481 220424.3 426227.5 ## P101007 13183206 309709728 316142400 715500800 448578400 14010174 368849632 3764448 404918560 57376512 50766284 588643712 181572112 189915296 7412535 369675.0 561078.5 ## P101009 7596680 325723168 232534688 742576768 473622240 14814230 365712768 3444159 298822048 26429340 43420376 631965888 208484000 186599152 5421984 172995.7 457043.3 ## P101010 5395172 382690720 262177072 642967424 647036736 12873290 376101984 3276579 373251712 21732290 43622724 590247424 306379392 217632736 5767624 168503.4 602024.4 ## P101011 4854076 261022832 264648720 728199680 378921056 13152187 348108832 2364665 335196864 21960100 39447380 560182336 136970272 170865408 3588338 375137.6 304329.9 ## M_19266 M_63739 M_57663 M_42489 M_37253 M_45095 M_53229 M_55072 M_47118 M_35253 M_46115 M_62952 M_63681 M_63361 ## P101001 176944.80 761146.2 719237.9 2865827 411578.0 751527.3 768160.4 488544.9 281162.7 27446600 1578011.4 5104806 434480.3 2540280 ## P101004 0.00 549097.4 364556.1 1546570 425030.0 378033.7 953194.9 653107.0 362380.0 28088842 440408.7 3084011 373229.5 2165454 ## P101007 385203.22 792883.2 500680.8 1403190 742298.0 589506.3 1619436.8 522721.5 482046.2 21613430 794592.2 4728273 400386.6 2231037 ## P101009 0.00 727360.0 523549.1 1653830 466825.0 503910.2 877530.2 873616.8 619943.9 28872470 671497.6 4140767 301840.8 0 ## P101010 0.00 913964.4 455201.1 1007203 232876.0 489013.9 993923.4 864624.8 677774.7 25375946 1133763.9 2434359 548330.4 1125607 ## P101011 90888.59 1609550.0 449288.0 1818438 651777.4 785751.6 1092817.9 1360312.8 208040.6 17388928 1635119.5 5722723 344799.8 0 4.5 Associations Among Features 4.5.1 Single network with SPRING as association measure InputData: numeric matrix. Can be a count matrix (rows are samples, columns are Features). Filtered criterion: Only samples with a total number of reads of at least 1000 are included (argument filtSamp). Only the 50 taxa with highest frequency are included (argument filtTax). Method to compute the associations between features (argument measure). Normalization method: normMethod: none. zeroMethod: none. sparsMethod: none. 4.5.1.1 Building network model (SPRING) net_single &lt;- netConstruct(features_tab, filtTax = &quot;highestFreq&quot;, filtTaxPar = list(highestFreq = 50), filtSamp = &quot;totalReads&quot;, filtSampPar = list(totalReads = 100), measure = &quot;spring&quot;, measurePar = list(nlambda = 10, rep.num = 10), normMethod = &quot;none&quot;, zeroMethod = &quot;none&quot;, sparsMethod = &quot;none&quot;, dissFunc = &quot;signed&quot;, verbose = 3, seed = 123) ## Data filtering ... ## 48 taxa and 45 samples remaining. ## ## Calculate &#39;spring&#39; associations ... ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## The input is identified as the covariance matrix. ## Conducting Meinshausen &amp; Buhlmann graph estimation (mb)....done ## Done. 4.5.1.2 Analyzing the constructed network (SPRING) props_single &lt;- netAnalyze(net_single, centrLCC = TRUE, clustMethod = &quot;cluster_fast_greedy&quot;, hubPar = &quot;eigenvector&quot;, weightDeg = FALSE, normDeg = FALSE) #?summary.microNetProps summary(props_single, numbNodes = 5L) ## ## Component sizes ## ``````````````` ## size: 24 3 2 1 ## #: 1 1 1 19 ## ______________________________ ## Global network properties ## ````````````````````````` ## Largest connected component (LCC): ## ## Relative LCC size 0.50000 ## Clustering coefficient 0.13809 ## Modularity 0.61719 ## Positive edge percentage 87.50000 ## Edge density 0.08696 ## Natural connectivity 0.05294 ## Vertex connectivity 1.00000 ## Edge connectivity 1.00000 ## Average dissimilarity* 0.97231 ## Average path length** 4.17479 ## ## Whole network: ## ## Number of components 22.00000 ## Clustering coefficient 0.13042 ## Modularity 0.67421 ## Positive edge percentage 88.88889 ## Edge density 0.02394 ## Natural connectivity 0.02400 ## ## *Dissimilarity = 1 - edge weight ## **Path length: Units with average dissimilarity ## ## ______________________________ ## Clusters ## - In the whole network ## - Algorithm: cluster_fast_greedy ## ```````````````````````````````` ## ## name: 0 1 2 3 4 5 6 7 ## #: 19 7 6 5 3 3 2 3 ## ## ______________________________ ## Hubs ## - In alphabetical/numerical order ## - Based on empirical quantiles of centralities ## ``````````````````````````````````````````````` ## M_42398 ## M_52447 ## M_52464 ## ## ______________________________ ## Centrality measures ## - In decreasing order ## - Centrality of disconnected components is zero ## ```````````````````````````````````````````````` ## Degree (unnormalized): ## ## M_36600 4 ## M_42398 4 ## M_52603 3 ## M_52447 3 ## M_19266 3 ## ## Betweenness centrality (normalized): ## ## M_19266 0.56126 ## M_42398 0.55731 ## M_42450 0.52174 ## M_52462 0.51383 ## M_39270 0.49802 ## ## Closeness centrality (normalized): ## ## M_42398 0.55454 ## M_36600 0.49039 ## M_19266 0.48425 ## M_39270 0.48005 ## M_52447 0.47460 ## ## Eigenvector centrality (normalized): ## ## M_52447 1.00000 ## M_42398 0.79014 ## M_52464 0.78767 ## M_55041 0.78469 ## M_35631 0.37519 4.5.1.3 Visualizing the network (SPRING) plot(props_single, nodeColor = &quot;cluster&quot;, nodeSize = &quot;eigenvector&quot;, title1 = &quot;Network on metabolomics with SPRING associations&quot;, showTitle = TRUE, cexTitle = 1.5) legend(0.7, 1.1, cex = 0.8, title = &quot;estimated association:&quot;, legend = c(&quot;+&quot;,&quot;-&quot;), lty = 1, lwd = 3, col = c(&quot;#009900&quot;,&quot;red&quot;), bty = &quot;n&quot;, horiz = TRUE) Figure 4.1: Network on metabolomics with SPRING associations Note that edge weights are (non-negative) similarities, however, the edges belonging to negative estimated associations are colored in red by default (negDiffCol = TRUE). 4.5.2 Single network with Pearson correlation as association measure Since Pearson correlations may lead to compositional effects when applied to sequencing data, we use the clr transformation as normalization method. Zero treatment is necessary in this case. A threshold of 0.3 is used as sparsification method, so that only OTUs with an absolute correlation greater than or equal to 0.3 are connected. 4.5.2.1 Building network model (Pearson) net_single2 &lt;- netConstruct(features_tab, measure = &quot;pearson&quot;, normMethod = &quot;clr&quot;, zeroMethod = &quot;multRepl&quot;, sparsMethod = &quot;threshold&quot;, thresh = 0.3, verbose = 3, seed = 123) ## 48 taxa and 45 samples remaining. ## ## Zero treatment: ## Execute multRepl() ... Done. ## ## Normalization: ## Execute clr(){SpiecEasi} ... Done. ## ## Calculate &#39;pearson&#39; associations ... Done. ## ## Sparsify associations via &#39;threshold&#39; ... Done. 4.5.2.2 Visualizing the network (Pearson) main plot props_single2 &lt;- netAnalyze(net_single2, clustMethod = &quot;cluster_fast_greedy&quot;) plot(props_single2, nodeColor = &quot;cluster&quot;, nodeSize = &quot;eigenvector&quot;, title1 = &quot;Network on metabolomics with Pearson correlations&quot;, showTitle = TRUE, cexTitle = 1.5) legend(0.7, 1.1, cex = 1, title = &quot;estimated correlation:&quot;, legend = c(&quot;+&quot;,&quot;-&quot;), lty = 1, lwd = 3, col = c(&quot;#009900&quot;,&quot;red&quot;), bty = &quot;n&quot;, horiz = TRUE) Figure 4.2: Network on metabolomics with Pearson associations Improved plot improve the visualization by changing the following arguments: repulsion = 0.8: Place the nodes further apart rmSingles = TRUE: Single nodes are removed labelScale = FALSE and cexLabels = 1.6: All labels have equal size and are enlarged to improve readability of small node’s labels nodeSizeSpread = 3 (default is 4): Node sizes are more similar if the value is decreased. This argument (in combination with cexNodes) is useful to enlarge small nodes while keeping the size of big nodes. plot(props_single2, nodeColor = &quot;cluster&quot;, nodeSize = &quot;eigenvector&quot;, repulsion = 0.8, rmSingles = TRUE, labelScale = FALSE, cexLabels = 1.6, nodeSizeSpread = 3, cexNodes = 2, title1 = &quot;Network on metabolomics with Pearson correlations&quot;, showTitle = TRUE, cexTitle = 1.5) legend(0.7, 1.1, cex = 1.2, title = &quot;estimated correlation:&quot;, legend = c(&quot;+&quot;,&quot;-&quot;), lty = 1, lwd = 3, col = c(&quot;#009900&quot;,&quot;red&quot;), bty = &quot;n&quot;, horiz = TRUE) Figure 4.3: Network on metabolomics with Pearson associations (improve) 4.5.3 Single network with SpiecEasi correlation as association measure Only the 50 features with highest variance are selected. Only samples with a total number of reads of at least 100 included. 4.5.3.1 Building network model (SpiecEasi) net_single3 &lt;- netConstruct(features_tab, measure = &quot;spieceasi&quot;, measurePar = list(method = &quot;mb&quot;, pulsar.params = list(rep.num = 10), symBetaMode = &quot;ave&quot;), filtTax = &quot;highestVar&quot;, filtTaxPar = list(highestVar = 50), filtSamp = &quot;totalReads&quot;, filtSampPar = list(totalReads = 100), verbose = 3, seed = 123) ## Infos about changed arguments: ## Sparsification included in &#39;spieceasi&#39;. ## Data filtering ... ## 48 taxa and 45 samples remaining. ## ## Calculate &#39;spieceasi&#39; associations ... ## Applying data transformations... ## Selecting model with pulsar using stars... ## Fitting final estimate with mb... ## done ## Done. 4.5.3.2 Visualizing the network (SpiecEasi) props_single3 &lt;- netAnalyze(net_single3, clustMethod = &quot;cluster_fast_greedy&quot;) plot(props_single3, nodeColor = &quot;cluster&quot;, nodeSize = &quot;eigenvector&quot;, repulsion = 0.8, rmSingles = TRUE, labelScale = FALSE, cexLabels = 1.6, nodeSizeSpread = 3, cexNodes = 2, title1 = &quot;Network on metabolomics with SpiecEasi correlations&quot;, showTitle = TRUE, cexTitle = 1.5) legend(0.7, 1.1, cex = 1.2, title = &quot;estimated correlation:&quot;, legend = c(&quot;+&quot;,&quot;-&quot;), lty = 1, lwd = 3, col = c(&quot;#009900&quot;,&quot;red&quot;), bty = &quot;n&quot;, horiz = TRUE) Figure 4.4: Network on metabolomics with SpiecEasi associations 4.5.4 Single network with WGCNA (bicor) as association measure Biweight Midcorrelation bicor() from WGCNA package. 4.5.4.1 Building network model (WGCNA) net_single4 &lt;- netConstruct(features_tab, measure = &quot;bicor&quot;, measurePar = list(use = &quot;all.obs&quot;, maxPOutliers = 1, nThreads = 2), filtTax = &quot;highestVar&quot;, filtTaxPar = list(highestVar = 50), filtSamp = &quot;totalReads&quot;, filtSampPar = list(totalReads = 100), dissFunc = &quot;TOMdiss&quot;, verbose = 3) ## Attention! The chosen combination of association measure ## and normalization is not robust to compositional effects. ## Data filtering ... ## 48 taxa and 45 samples remaining. ## ## Calculate &#39;bicor&#39; associations ... ## ..will use 2 parallel threads. ## Fraction of slow calculations: 0.000000 ## Done. ## ## Sparsify associations via &#39;t-test&#39; ... ## Adjust for multiple testing via &#39;adaptBH&#39; ... ## Proportion of true null hypotheses: 0.43 ## Done. ## Done. 4.5.4.2 Visualizing the network (WGCNA) props_single4 &lt;- netAnalyze(net_single4, clustMethod = &quot;cluster_fast_greedy&quot;) plot(props_single4, nodeColor = &quot;cluster&quot;, nodeSize = &quot;eigenvector&quot;, repulsion = 0.8, rmSingles = TRUE, labelScale = FALSE, cexLabels = 1.6, nodeSizeSpread = 3, cexNodes = 2, title1 = &quot;Network on metabolomics with WGCNA correlations&quot;, showTitle = TRUE, cexTitle = 1.5) legend(0.7, 1.1, cex = 1.2, title = &quot;estimated correlation:&quot;, legend = c(&quot;+&quot;,&quot;-&quot;), lty = 1, lwd = 3, col = c(&quot;#009900&quot;,&quot;red&quot;), bty = &quot;n&quot;, horiz = TRUE) Figure 4.5: Network on metabolomics with WGCNA associations 4.5.5 Single network with sparcc correlation as association measure Only the 50 features with highest variance are selected. Only samples with a total number of reads of at least 100 included. 4.5.5.1 Building network model (sparcc) net_single5 &lt;- netConstruct(features_tab, measure = &quot;sparcc&quot;, measurePar = list(iter = 20, inner_iter = 10, th = 0.1), filtTax = &quot;highestVar&quot;, filtTaxPar = list(highestVar = 50), filtSamp = &quot;totalReads&quot;, filtSampPar = list(totalReads = 100), verbose = 3, seed = 123) ## Data filtering ... ## 48 taxa and 45 samples remaining. ## ## Calculate &#39;sparcc&#39; associations ... Done. ## ## Sparsify associations via &#39;t-test&#39; ... ## Adjust for multiple testing via &#39;adaptBH&#39; ... ## Proportion of true null hypotheses: 0.37 ## Done. ## Done. 4.5.5.2 Visualizing the network (sparcc) props_single5 &lt;- netAnalyze(net_single5, clustMethod = &quot;cluster_fast_greedy&quot;) plot(props_single5, nodeColor = &quot;cluster&quot;, nodeSize = &quot;eigenvector&quot;, repulsion = 0.8, rmSingles = TRUE, labelScale = FALSE, cexLabels = 1.6, nodeSizeSpread = 3, cexNodes = 2, title1 = &quot;Network on metabolomics with sparcc correlations&quot;, showTitle = TRUE, cexTitle = 1.5) legend(0.7, 1.1, cex = 1.2, title = &quot;estimated correlation:&quot;, legend = c(&quot;+&quot;,&quot;-&quot;), lty = 1, lwd = 3, col = c(&quot;#009900&quot;,&quot;red&quot;), bty = &quot;n&quot;, horiz = TRUE) Figure 4.6: Network on metabolomics with sparcc associations 4.6 Dissimilarity-based Networks If a dissimilarity measure is used for network construction, nodes are subjects instead of OTUs. The estimated dissimilarities are transformed into similarities, which are used as edge weights so that subjects with a similar microbial composition are placed close together in the network plot. We construct a single network using Aitchison’s distance being suitable for the application on compositional data. Since the Aitchison distance is based on the clr-transformation, zeros in the data need to be replaced. The network is sparsified using the k-nearest neighbor (knn) algorithm. 4.6.1 Building network module (Dissimilarity-based) net_aitchison &lt;- netConstruct(features_tab, measure = &quot;aitchison&quot;, zeroMethod = &quot;multRepl&quot;, sparsMethod = &quot;knn&quot;, kNeighbor = 3, verbose = 3) ## Infos about changed arguments: ## Counts normalized to fractions for measure &#39;aitchison&#39;. ## 48 taxa and 45 samples remaining. ## ## Zero treatment: ## Execute multRepl() ... Done. ## ## Normalization: ## Counts normalized by total sum scaling. ## ## Calculate &#39;aitchison&#39; dissimilarities ... Done. ## ## Sparsify dissimilarities via &#39;knn&#39; ... Done. 4.6.2 Analyzing the constructed network (Dissimilarity-based) NetCoMi’s netAnalyze() function is used for analyzing the constructed network(s). props_aitchison &lt;- netAnalyze(net_aitchison, clustMethod = &quot;hierarchical&quot;, clustPar = list(method = &quot;average&quot;, k = 3), hubPar = &quot;eigenvector&quot;) summary(props_aitchison, numbNodes = 5L) ## ## Component sizes ## ``````````````` ## size: 45 ## #: 1 ## ______________________________ ## Global network properties ## ````````````````````````` ## ## Number of components 1.00000 ## Clustering coefficient 0.40878 ## Modularity 0.45394 ## Positive edge percentage 100.00000 ## Edge density 0.10707 ## Natural connectivity 0.07361 ## Vertex connectivity 1.00000 ## Edge connectivity 1.00000 ## Average dissimilarity* 0.91417 ## Average path length** 1.09339 ## ## *Dissimilarity = 1 - edge weight ## **Path length: Units with average dissimilarity ## ## ______________________________ ## Clusters ## - In the whole network ## - Algorithm: hierarchical ## ````````````````````````` ## ## name: 1 2 3 ## #: 26 15 4 ## ## ______________________________ ## Hubs ## - In alphabetical/numerical order ## - Based on empirical quantiles of centralities ## ``````````````````````````````````````````````` ## P101009 ## P101027 ## P101081 ## ## ______________________________ ## Centrality measures ## - In decreasing order ## - Computed for the complete network ## ```````````````````````````````````` ## Degree (normalized): ## ## P101007 0.31818 ## P101013 0.22727 ## P101009 0.20455 ## P101018 0.18182 ## P101027 0.18182 ## ## Betweenness centrality (normalized): ## ## P101069 0.45983 ## P101031 0.44397 ## P101007 0.43763 ## P101050 0.40169 ## P101004 0.27590 ## ## Closeness centrality (normalized): ## ## P101064 3.47289 ## P101009 3.33131 ## P101057 3.25585 ## P101004 3.08595 ## P101007 2.94787 ## ## Eigenvector centrality (normalized): ## ## P101009 1.00000 ## P101027 0.90864 ## P101081 0.81874 ## P101004 0.77399 ## P101012 0.59863 4.6.3 Visualizing the network (Dissimilarity-based) main plot plot(props_aitchison, nodeColor = &quot;cluster&quot;, nodeSize = &quot;eigenvector&quot;, repulsion = 0.8, rmSingles = TRUE, labelScale = FALSE, cexLabels = 1.6, nodeSizeSpread = 3, cexNodes = 1.5, title1 = &quot;Network on metabolomics with Aitchison distance&quot;, showTitle = TRUE, cexTitle = 1.5, hubTransp = 50, edgeTranspLow = 60, charToRm = &quot;00000&quot;, mar = c(1, 3, 3, 5)) # plot(props_aitchison, # nodeColor = &quot;cluster&quot;, # nodeSize = &quot;eigenvector&quot;, # hubTransp = 50, # edgeTranspLow = 60, # charToRm = &quot;00000&quot;, # mar = c(1, 3, 3, 5)) # get green color with 50% transparency green2 &lt;- colToTransp(&quot;#009900&quot;, 40) legend(0.4, 1.1, cex = 1.5, legend = c(&quot;high similarity (low Aitchison distance)&quot;, &quot;low similarity (high Aitchison distance)&quot;), lty = 1, lwd = c(3, 1), col = c(&quot;darkgreen&quot;, green2), bty = &quot;n&quot;) Figure 4.7: Dissimilarity-based Networks plot samples with group information # Get gorup names from the sample table created before sampletab &lt;- se_filter@colData %&gt;% data.frame() group_labels &lt;- factor(sampletab$group) names(group_labels) &lt;- rownames(sampletab) # Define group colors group_lcol &lt;- c(&quot;cyan&quot;, &quot;blue3&quot;, &quot;red&quot;) plot(props_aitchison, layout = &quot;spring&quot;, repulsion = 0.84, shortenLabels = &quot;none&quot;, labelScale = FALSE, rmSingles = TRUE, nodeSize = &quot;eigenvector&quot;, nodeSizeSpread = 4, nodeColor = &quot;feature&quot;, featVecCol = group_labels, colorVec = group_lcol, posCol = &quot;darkturquoise&quot;, negCol = &quot;orange&quot;, edgeTranspLow = 0, edgeTranspHigh = 40, cexNodes = 2, cexLabels = 2, cexHubLabels = 2.5, title1 = &quot;Network on metabolomics with Aitchison distance&quot;, showTitle = TRUE, cexTitle = 2.3) # Colors used in the legend should be equally transparent as in the plot group_transp &lt;- NetCoMi:::colToTransp(group_lcol, 60) legend(-1.2, 1.2, cex = 2, pt.cex = 2.5, title = &quot;Group:&quot;, legend = levels(group_labels), col = group_transp, bty = &quot;n&quot;, pch = 16) # get green color with 50% transparency green2 &lt;- colToTransp(&quot;#009900&quot;, 40) legend(0.4, 1.1, cex = 1.5, legend = c(&quot;high similarity (low Aitchison distance)&quot;, &quot;low similarity (high Aitchison distance)&quot;), lty = 1, lwd = c(3, 1), col = c(&quot;darkgreen&quot;, green2), bty = &quot;n&quot;) Figure 4.8: Dissimilarity-based Networks (group information) 4.7 Network comparison Comparing two networks by NetCoMi. 4.7.1 Data preparing group_names &lt;- c(&quot;Mild&quot;, &quot;Severe&quot;) se_filter_subset &lt;- se_filter[, se_filter$group %in% group_names] se_filter_subset$group &lt;- factor(as.character(se_filter_subset$group)) features_tab &lt;- SummarizedExperiment::assay(se_filter_subset) %&gt;% t() features_tab[is.na(features_tab)] &lt;- 0 group_vector &lt;- se_filter_subset$group 4.7.2 Building network model net_group &lt;- netConstruct(features_tab, group = group_vector, measure = &quot;pearson&quot;, normMethod = &quot;clr&quot;, zeroMethod = &quot;multRepl&quot;, sparsMethod = &quot;threshold&quot;, thresh = 0.3, verbose = 3, seed = 123) ## 48 taxa and 26 samples remaining. ## ## Zero treatment: ## Execute multRepl() ... Done. ## ## Normalization: ## Execute clr(){SpiecEasi} ... Done. ## ## Calculate &#39;pearson&#39; associations ... Done. ## ## Calculate associations in group 2 ... Done. ## ## Sparsify associations via &#39;threshold&#39; ... Done. ## ## Sparsify associations in group 2 ... Done. 4.7.3 Network analysis props_group &lt;- netAnalyze(net_group, centrLCC = FALSE, avDissIgnoreInf = TRUE, sPathNorm = FALSE, clustMethod = &quot;cluster_fast_greedy&quot;, hubPar = c(&quot;degree&quot;, &quot;between&quot;, &quot;closeness&quot;), hubQuant = 0.9, lnormFit = TRUE, normDeg = FALSE, normBetw = FALSE, normClose = FALSE, normEigen = FALSE) summary(props_group) ## ## Component sizes ## ``````````````` ## Group 1: ## size: 48 ## #: 1 ## ## Group 2: ## size: 48 ## #: 1 ## ______________________________ ## Global network properties ## ````````````````````````` ## group &#39;1&#39; group &#39;2&#39; ## Number of components 1.00000 1.00000 ## Clustering coefficient 0.50151 0.48747 ## Modularity 0.15580 0.08807 ## Positive edge percentage 51.11607 49.24078 ## Edge density 0.39716 0.40869 ## Natural connectivity 0.09563 0.08721 ## Vertex connectivity 9.00000 7.00000 ## Edge connectivity 9.00000 7.00000 ## Average dissimilarity* 0.67288 0.68152 ## Average path length** 0.92286 0.91581 ## ## *Dissimilarity = 1 - edge weight ## **Path length: Sum of dissimilarities along the path ## ## ______________________________ ## Clusters ## - In the whole network ## - Algorithm: cluster_fast_greedy ## ```````````````````````````````` ## group &#39;1&#39;: ## name: 1 2 3 4 ## #: 6 15 14 13 ## ## group &#39;2&#39;: ## name: 1 2 3 4 ## #: 18 10 12 8 ## ## ______________________________ ## Hubs ## - In alphabetical/numerical order ## - Based on log-normal quantiles of centralities ## ``````````````````````````````````````````````` ## No hubs detected. ## ______________________________ ## Centrality measures ## - In decreasing order ## - Computed for the complete network ## ```````````````````````````````````` ## Degree (unnormalized): ## group &#39;1&#39; group &#39;2&#39; ## M_48258 29 19 ## M_42398 26 25 ## M_47118 26 27 ## M_35186 25 22 ## M_55072 24 21 ## ______ ______ ## M_47118 26 27 ## M_19130 14 26 ## M_42446 18 26 ## M_33230 22 25 ## M_52452 23 25 ## ## Betweenness centrality (unnormalized): ## group &#39;1&#39; group &#39;2&#39; ## M_35186 51 5 ## M_42450 31 27 ## M_52452 31 18 ## M_42398 31 20 ## M_35253 31 5 ## ______ ______ ## M_19130 5 34 ## M_33230 3 32 ## M_63361 5 31 ## M_53189 7 27 ## M_42450 31 27 ## ## Closeness centrality (unnormalized): ## group &#39;1&#39; group &#39;2&#39; ## M_35253 71.79398 51.58148 ## M_42398 70.9484 63.74822 ## M_33961 68.32261 55.35701 ## M_48258 67.49245 61.7771 ## M_33955 66.93392 57.32211 ## ______ ______ ## M_52447 63.54214 66.40753 ## M_52464 62.24541 65.07936 ## M_33230 62.53671 63.84338 ## M_42398 70.9484 63.74822 ## M_47118 64.7125 63.10391 ## ## Eigenvector centrality (unnormalized): ## group &#39;1&#39; group &#39;2&#39; ## M_42398 0.26682 0.21086 ## M_35253 0.26167 0.08052 ## M_48258 0.25696 0.1782 ## M_35186 0.23664 0.20434 ## M_33961 0.23245 0.11227 ## ______ ______ ## M_33230 0.18321 0.21563 ## M_47118 0.20899 0.21435 ## M_42398 0.26682 0.21086 ## M_35186 0.23664 0.20434 ## M_52447 0.13304 0.18604 4.7.4 Visualizing the network plot(props_group, sameLayout = TRUE, layoutGroup = 1, rmSingles = &quot;inboth&quot;, nodeSize = &quot;mclr&quot;, labelScale = FALSE, cexNodes = 1, cexLabels = 1.5, cexHubLabels = 2, cexTitle = 2, groupNames = group_names, hubBorderCol = &quot;gray40&quot;) legend(&quot;bottom&quot;, title = &quot;estimated association:&quot;, legend = c(&quot;+&quot;, &quot;-&quot;), col = c(&quot;#009900&quot;,&quot;red&quot;), inset = 0.04, cex = 3, lty = 1, lwd = 4, bty = &quot;n&quot;, horiz = TRUE) Figure 4.9: Network comparison 4.7.5 Quantitative network comparison comp_group &lt;- netCompare(props_group, permTest = FALSE, verbose = FALSE) summary(comp_group, groupNames = group_names, showCentr = c(&quot;degree&quot;, &quot;between&quot;, &quot;closeness&quot;), numbNodes = 5) ## ## Comparison of Network Properties ## ---------------------------------- ## CALL: ## netCompare(x = props_group, permTest = FALSE, verbose = FALSE) ## ## ______________________________ ## Global network properties ## ````````````````````````` ## Mild Severe difference ## Number of components 1.000 1.000 0.000 ## Clustering coefficient 0.502 0.487 0.014 ## Moduarity 0.156 0.088 0.068 ## Positive edge percentage 51.116 49.241 1.875 ## Edge density 0.397 0.409 0.012 ## Natural connectivity 0.096 0.087 0.008 ## Vertex connectivity 9.000 7.000 2.000 ## Edge connectivity 9.000 7.000 2.000 ## Average dissimilarity* 0.673 0.682 0.009 ## Average path length** 0.923 0.916 0.007 ## ----- ## *: Dissimilarity = 1 - edge weight ## **Path length: Sum of dissimilarities along the path ## ## ______________________________ ## Jaccard index (similarity betw. sets of most central nodes) ## `````````````````````````````````````````````````````````` ## Jacc P(&lt;=Jacc) P(&gt;=Jacc) ## degree 0.278 0.412243 0.768928 ## betweenness centr. 0.120 0.014890 * 0.996495 ## closeness centr. 0.300 0.479343 0.702786 ## eigenvec. centr. 0.444 0.892398 0.223260 ## hub taxa 0.000 1.000000 1.000000 ## ----- ## Jaccard index ranges from 0 (compl. different) to 1 (sets equal) ## ## ______________________________ ## Adjusted Rand index (similarity betw. clusterings) ## `````````````````````````````````````````````````` ## ARI p-value ## 0.121 0 ## ----- ## ARI in [-1,1] with ARI=1: perfect agreement betw. clusterings, ## ARI=0: expected for two random clusterings ## p-value: two-tailed test with null hypothesis ARI=0 ## ## ______________________________ ## Centrality measures ## - In decreasing order ## - Computed for the complete network ## ```````````````````````````````````` ## Degree (unnormalized): ## Mild Severe abs.diff. ## M_19130 14 26 12 ## M_19266 21 10 11 ## M_48258 29 19 10 ## M_49617 10 19 9 ## M_35253 24 15 9 ## ## Betweenness centrality (unnormalized): ## Mild Severe abs.diff. ## M_35186 51 5 46 ## M_19130 5 34 29 ## M_33230 3 32 29 ## M_63361 5 31 26 ## M_53229 27 1 26 ## ## Closeness centrality (unnormalized): ## Mild Severe abs.diff. ## M_35253 71.794 51.581 20.213 ## M_33961 68.323 55.357 12.966 ## M_49617 46.281 57.240 10.958 ## M_53189 49.398 59.611 10.213 ## M_33955 66.934 57.322 9.612 ## ## _________________________________________________________ ## Significance codes: ***: 0.001, **: 0.01, *: 0.05, .: 0.1 4.8 Session info devtools::session_info() ## ─ Session info ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.3 (2020-02-29) ## os Ubuntu 16.04.7 LTS ## system x86_64, linux-gnu ## ui RStudio ## language (EN) ## collate en_IN.UTF-8 ## ctype en_IN.UTF-8 ## tz Asia/Hong_Kong ## date 2022-09-15 ## rstudio 1.1.419 (server) ## pandoc 2.7.3 @ /usr/bin/ (via rmarkdown) ## ## ─ Packages ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ## ! package * version date (UTC) lib source ## abind 1.4-5 2016-07-21 [1] CRAN (R 3.6.3) ## ade4 1.7-17 2021-06-17 [1] CRAN (R 3.6.3) ## AnnotationDbi 1.58.0 2022-04-26 [1] Bioconductor ## ape 5.5 2021-04-25 [1] CRAN (R 3.6.3) ## assertthat 0.2.1 2019-03-21 [2] CRAN (R 3.6.3) ## backports 1.4.1 2021-12-13 [1] CRAN (R 3.6.3) ## base64enc 0.1-3 2015-07-28 [2] CRAN (R 3.6.3) ## Biobase * 2.46.0 2019-10-29 [2] Bioconductor ## BiocGenerics * 0.32.0 2019-10-29 [2] Bioconductor ## BiocParallel * 1.20.1 2019-12-21 [2] Bioconductor ## biomformat 1.14.0 2019-10-29 [1] Bioconductor ## Biostrings 2.54.0 2019-10-29 [1] Bioconductor ## bit 4.0.4 2020-08-04 [1] CRAN (R 3.6.3) ## bit64 4.0.5 2020-08-30 [1] CRAN (R 3.6.3) ## bitops 1.0-7 2021-04-24 [1] CRAN (R 3.6.3) ## blob 1.2.2 2021-07-23 [1] CRAN (R 3.6.3) ## bookdown 0.24 2021-09-02 [1] CRAN (R 3.6.3) ## brio 1.1.3 2021-11-30 [2] CRAN (R 3.6.3) ## broom 0.7.12 2022-01-28 [1] CRAN (R 3.6.3) ## bslib 0.3.1 2021-10-06 [1] CRAN (R 3.6.3) ## cachem 1.0.5 2021-05-15 [1] CRAN (R 3.6.3) ## callr 3.7.0 2021-04-20 [2] CRAN (R 3.6.3) ## caTools 1.18.2 2021-03-28 [1] CRAN (R 3.6.3) ## cccd 1.6 2022-04-08 [1] CRAN (R 3.6.3) ## cellranger 1.1.0 2016-07-27 [1] CRAN (R 3.6.3) ## checkmate 2.0.0 2020-02-06 [1] CRAN (R 3.6.3) ## cli 3.1.0 2021-10-27 [1] CRAN (R 3.6.3) ## cluster 2.1.0 2019-06-19 [2] CRAN (R 3.6.3) ## codetools 0.2-16 2018-12-24 [2] CRAN (R 3.6.3) ## colorspace 2.0-2 2021-06-24 [1] CRAN (R 3.6.3) ## corpcor 1.6.10 2021-09-16 [2] CRAN (R 3.6.3) ## cowplot 1.1.1 2020-12-30 [1] CRAN (R 3.6.3) ## crayon 1.5.0 2022-02-14 [1] CRAN (R 3.6.3) ## crosstalk 1.2.0 2021-11-04 [2] CRAN (R 3.6.3) ## data.table 1.14.0 2021-02-21 [1] CRAN (R 3.6.3) ## DBI 1.1.1 2021-01-15 [1] CRAN (R 3.6.3) ## dbplyr 2.1.1 2021-04-06 [1] CRAN (R 3.6.3) ## DelayedArray * 0.12.3 2020-04-09 [2] Bioconductor ## deldir 1.0-6 2021-10-23 [2] CRAN (R 3.6.3) ## desc 1.4.1 2022-03-06 [2] CRAN (R 3.6.3) ## devtools 2.4.3 2021-11-30 [1] CRAN (R 3.6.3) ## digest 0.6.29 2021-12-01 [1] CRAN (R 3.6.3) ## doParallel 1.0.17 2022-02-07 [2] CRAN (R 3.6.3) ## doSNOW 1.0.20 2022-02-04 [1] CRAN (R 3.6.3) ## dplyr * 1.0.6 2021-05-05 [1] CRAN (R 3.6.3) ## DT * 0.23 2022-05-10 [2] CRAN (R 3.6.3) ## dynamicTreeCut * 1.63-1 2016-03-11 [1] CRAN (R 3.6.3) ## ellipsis 0.3.2 2021-04-29 [1] CRAN (R 3.6.3) ## evaluate 0.15 2022-02-18 [2] CRAN (R 3.6.3) ## fansi 1.0.2 2022-01-14 [1] CRAN (R 3.6.3) ## farver 2.1.0 2021-02-28 [2] CRAN (R 3.6.3) ## fastcluster * 1.2.3 2021-05-24 [1] CRAN (R 3.6.3) ## fastmap 1.1.0 2021-01-25 [1] CRAN (R 3.6.3) ## fdrtool 1.2.17 2021-11-13 [1] CRAN (R 3.6.3) ## filematrix 1.3 2018-02-27 [1] CRAN (R 3.6.3) ## FNN 1.1.3 2019-02-15 [1] CRAN (R 3.6.3) ## forcats * 0.5.1 2021-01-27 [1] CRAN (R 3.6.3) ## foreach 1.5.2 2022-02-02 [2] CRAN (R 3.6.3) ## foreign 0.8-75 2020-01-20 [2] CRAN (R 3.6.3) ## Formula 1.2-4 2020-10-16 [1] CRAN (R 3.6.3) ## fs 1.5.2 2021-12-08 [1] CRAN (R 3.6.3) ## generics 0.1.2 2022-01-31 [1] CRAN (R 3.6.3) ## GenomeInfoDb * 1.22.1 2020-03-27 [2] Bioconductor ## GenomeInfoDbData 1.2.2 2020-08-24 [2] Bioconductor ## GenomicRanges * 1.38.0 2019-10-29 [2] Bioconductor ## ggforce 0.3.3 2021-03-05 [1] CRAN (R 3.6.3) ## ggplot2 * 3.3.5 2021-06-25 [1] CRAN (R 3.6.3) ## ggraph * 2.0.5 2021-02-23 [1] CRAN (R 3.6.3) ## ggrepel 0.9.1 2021-01-15 [2] CRAN (R 3.6.3) ## glasso 1.11 2019-10-01 [1] CRAN (R 3.6.3) ## glmnet 4.1-2 2021-06-24 [1] CRAN (R 3.6.3) ## glue 1.6.1 2022-01-22 [1] CRAN (R 3.6.3) ## GO.db 3.15.0 2022-09-14 [1] Bioconductor ## gplots 3.1.1 2020-11-28 [1] CRAN (R 3.6.3) ## graphlayouts 0.7.2 2021-11-21 [1] CRAN (R 3.6.3) ## gridExtra 2.3 2017-09-09 [2] CRAN (R 3.6.3) ## gtable 0.3.0 2019-03-25 [2] CRAN (R 3.6.3) ## gtools 3.9.2 2021-06-06 [1] CRAN (R 3.6.3) ## haven 2.4.1 2021-04-23 [1] CRAN (R 3.6.3) ## highr 0.9 2021-04-16 [1] CRAN (R 3.6.3) ## Hmisc 4.5-0 2021-02-28 [1] CRAN (R 3.6.3) ## hms 1.1.1 2021-09-26 [1] CRAN (R 3.6.3) ## htmlTable 2.3.0 2021-10-12 [1] CRAN (R 3.6.3) ## htmltools 0.5.2 2021-08-25 [1] CRAN (R 3.6.3) ## htmlwidgets 1.5.4 2021-09-08 [2] CRAN (R 3.6.3) ## httr 1.4.3 2022-05-04 [2] CRAN (R 3.6.3) ## huge 1.3.5 2021-06-30 [1] CRAN (R 3.6.3) ## igraph * 1.3.1 2022-04-20 [2] CRAN (R 3.6.3) ## IHW 1.14.0 2019-10-29 [1] Bioconductor ## impute 1.60.0 2019-10-29 [2] Bioconductor ## IRanges * 2.20.2 2020-01-13 [2] Bioconductor ## irlba 2.3.4 2021-12-03 [1] CRAN (R 3.6.3) ## iterators 1.0.14 2022-02-05 [2] CRAN (R 3.6.3) ## jpeg 0.1-9 2021-07-24 [1] CRAN (R 3.6.3) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 3.6.3) ## jsonlite 1.8.0 2022-02-22 [2] CRAN (R 3.6.3) ## KEGGREST 1.26.1 2019-11-06 [1] Bioconductor ## KernSmooth 2.23-16 2019-10-15 [2] CRAN (R 3.6.3) ## knitr 1.36 2021-09-29 [1] CRAN (R 3.6.3) ## labeling 0.4.2 2020-10-20 [2] CRAN (R 3.6.3) ## lattice 0.20-38 2018-11-04 [2] CRAN (R 3.6.3) ## latticeExtra 0.6-29 2019-12-19 [1] CRAN (R 3.6.3) ## lavaan 0.6-12 2022-07-04 [1] CRAN (R 3.6.3) ## lazyeval 0.2.2 2019-03-15 [2] CRAN (R 3.6.3) ## lifecycle 1.0.1 2021-09-24 [1] CRAN (R 3.6.3) ## limma 3.42.2 2020-02-03 [2] Bioconductor ## locfit 1.5-9.4 2020-03-25 [1] CRAN (R 3.6.3) ## lpsymphony 1.14.0 2019-10-29 [1] Bioconductor (R 3.6.3) ## lubridate 1.7.10 2021-02-26 [1] CRAN (R 3.6.3) ## magrittr 2.0.2 2022-01-26 [1] CRAN (R 3.6.3) ## MASS 7.3-54 2021-05-03 [1] CRAN (R 3.6.3) ## Matrix 1.3-4 2021-06-01 [1] CRAN (R 3.6.3) ## matrixStats * 0.60.0 2021-07-26 [1] CRAN (R 3.6.3) ## memoise 2.0.1 2021-11-26 [2] CRAN (R 3.6.3) ## metagenomeSeq 1.28.2 2020-02-03 [1] Bioconductor ## mgcv 1.8-31 2019-11-09 [2] CRAN (R 3.6.3) ## mixedCCA 1.6.2 2022-09-15 [1] Github (irinagain/mixedCCA@4c2b63f) ## mnormt 2.0.2 2020-09-01 [1] CRAN (R 3.6.3) ## modelr 0.1.8 2020-05-19 [1] CRAN (R 3.6.3) ## multtest 2.42.0 2019-10-29 [2] Bioconductor ## munsell 0.5.0 2018-06-12 [2] CRAN (R 3.6.3) ## mvtnorm 1.1-3 2021-10-08 [1] CRAN (R 3.6.3) ## NADA 1.6-1.1 2020-03-22 [1] CRAN (R 3.6.3) ## NetCoMi * 1.0.3 2022-09-15 [1] Github (stefpeschel/NetCoMi@1260971) ## nlme 3.1-144 2020-02-06 [2] CRAN (R 3.6.3) ## nnet 7.3-12 2016-02-02 [2] CRAN (R 3.6.3) ## pbapply 1.5-0 2021-09-16 [1] CRAN (R 3.6.3) ## pbivnorm 0.6.0 2015-01-23 [1] CRAN (R 3.6.3) ## pcaPP 1.9-74 2021-04-23 [1] CRAN (R 3.6.3) ## permute 0.9-5 2019-03-12 [1] CRAN (R 3.6.3) ## pheatmap 1.0.12 2019-01-04 [1] CRAN (R 3.6.3) ## phyloseq * 1.30.0 2019-10-29 [1] Bioconductor ## pillar 1.7.0 2022-02-01 [1] CRAN (R 3.6.3) ## pkgbuild 1.3.1 2021-12-20 [2] CRAN (R 3.6.3) ## pkgconfig 2.0.3 2019-09-22 [2] CRAN (R 3.6.3) ## pkgload 1.2.4 2021-11-30 [2] CRAN (R 3.6.3) ## plotly * 4.10.0 2021-10-09 [1] CRAN (R 3.6.3) ## plyr 1.8.7 2022-03-24 [2] CRAN (R 3.6.3) ## png 0.1-7 2013-12-03 [1] CRAN (R 3.6.3) ## polyclip 1.10-0 2019-03-14 [1] CRAN (R 3.6.3) ## preprocessCore 1.48.0 2019-10-29 [2] Bioconductor ## prettyunits 1.1.1 2020-01-24 [2] CRAN (R 3.6.3) ## processx 3.5.3 2022-03-25 [2] CRAN (R 3.6.3) ## proxy 0.4-26 2021-06-07 [2] CRAN (R 3.6.3) ## ps 1.7.0 2022-04-23 [2] CRAN (R 3.6.3) ## psych 2.1.9 2021-09-22 [1] CRAN (R 3.6.3) ## pulsar 0.3.7 2020-08-07 [1] CRAN (R 3.6.3) ## purrr * 0.3.4 2020-04-17 [2] CRAN (R 3.6.3) ## qgraph 1.9.2 2022-03-04 [1] CRAN (R 3.6.3) ## R6 2.5.1 2021-08-19 [1] CRAN (R 3.6.3) ## rbibutils 2.2.5 2021-12-04 [1] CRAN (R 3.6.3) ## RColorBrewer 1.1-3 2022-04-03 [2] CRAN (R 3.6.3) ## Rcpp 1.0.7 2021-07-07 [1] CRAN (R 3.6.3) ## RCurl 1.98-1.6 2022-02-08 [2] CRAN (R 3.6.3) ## Rdpack 2.1.2 2021-06-01 [1] CRAN (R 3.6.3) ## readr * 2.0.0 2021-07-20 [1] CRAN (R 3.6.3) ## readxl 1.3.1 2019-03-13 [1] CRAN (R 3.6.3) ## remotes 2.4.2 2021-11-30 [1] CRAN (R 3.6.3) ## reprex 2.0.1 2021-08-05 [1] CRAN (R 3.6.3) ## reshape2 1.4.4 2020-04-09 [2] CRAN (R 3.6.3) ## rhdf5 2.30.1 2019-11-26 [1] Bioconductor ## Rhdf5lib 1.8.0 2019-10-29 [1] Bioconductor ## rJava 1.0-5 2021-09-24 [1] CRAN (R 3.6.3) ## R rlang 1.0.2 &lt;NA&gt; [2] &lt;NA&gt; ## rmarkdown 2.11 2021-09-14 [1] CRAN (R 3.6.3) ## rootSolve 1.8.2.3 2021-09-29 [1] CRAN (R 3.6.3) ## rpart 4.1-15 2019-04-12 [2] CRAN (R 3.6.3) ## rprojroot 2.0.2 2020-11-15 [1] CRAN (R 3.6.3) ## RSQLite 2.2.7 2021-04-22 [1] CRAN (R 3.6.3) ## rstudioapi 0.13 2020-11-12 [2] CRAN (R 3.6.3) ## rvest 1.0.2 2021-10-16 [1] CRAN (R 3.6.3) ## S4Vectors * 0.24.4 2020-04-09 [2] Bioconductor ## sass 0.4.0 2021-05-12 [1] CRAN (R 3.6.3) ## scales 1.2.0 2022-04-13 [2] CRAN (R 3.6.3) ## sessioninfo 1.2.2 2021-12-06 [2] CRAN (R 3.6.3) ## shape 1.4.6 2021-05-19 [1] CRAN (R 3.6.3) ## slam 0.1-49 2021-11-17 [1] CRAN (R 3.6.3) ## snow 0.4-4 2021-10-27 [2] CRAN (R 3.6.3) ## SpiecEasi * 1.1.2 2022-04-19 [1] Github (zdk123/SpiecEasi@c463727) ## SPRING * 1.0.4 2022-09-15 [1] Github (GraceYoon/SPRING@3d641a4) ## stringi 1.7.4 2021-08-25 [1] CRAN (R 3.6.3) ## stringr * 1.4.0 2019-02-10 [2] CRAN (R 3.6.3) ## SummarizedExperiment * 1.16.1 2019-12-19 [2] Bioconductor ## survival 3.1-8 2019-12-03 [2] CRAN (R 3.6.3) ## testthat 3.1.4 2022-04-26 [2] CRAN (R 3.6.3) ## tibble * 3.1.6 2021-11-07 [1] CRAN (R 3.6.3) ## tidygraph 1.2.0 2020-05-12 [1] CRAN (R 3.6.3) ## tidyr * 1.2.0 2022-02-01 [1] CRAN (R 3.6.3) ## tidyselect 1.1.1 2021-04-30 [1] CRAN (R 3.6.3) ## tidyverse * 1.3.1 2021-04-15 [1] CRAN (R 3.6.3) ## tmvnsim 1.0-2 2016-12-15 [1] CRAN (R 3.6.3) ## truncnorm 1.0-8 2018-02-27 [1] CRAN (R 3.6.3) ## tweenr 1.0.2 2021-03-23 [1] CRAN (R 3.6.3) ## tzdb 0.2.0 2021-10-27 [1] CRAN (R 3.6.3) ## usethis 2.1.6 2022-05-25 [2] CRAN (R 3.6.3) ## utf8 1.2.2 2021-07-24 [1] CRAN (R 3.6.3) ## vctrs 0.3.8 2021-04-29 [1] CRAN (R 3.6.3) ## vegan 2.5-7 2020-11-28 [1] CRAN (R 3.6.3) ## VGAM 1.1-6 2022-02-14 [1] CRAN (R 3.6.3) ## viridis 0.6.2 2021-10-13 [1] CRAN (R 3.6.3) ## viridisLite 0.4.0 2021-04-13 [2] CRAN (R 3.6.3) ## WGCNA * 1.71 2022-04-22 [1] CRAN (R 3.6.3) ## withr 2.4.3 2021-11-30 [1] CRAN (R 3.6.3) ## Wrench 1.4.0 2019-10-29 [1] Bioconductor ## xfun 0.23 2021-05-15 [1] CRAN (R 3.6.3) ## xlsx * 0.6.5 2020-11-10 [1] CRAN (R 3.6.3) ## xlsxjars 0.6.1 2014-08-22 [1] CRAN (R 3.6.3) ## xml2 1.3.3 2021-11-30 [2] CRAN (R 3.6.3) ## XVector 0.26.0 2019-10-29 [2] Bioconductor ## yaml 2.2.2 2022-01-25 [1] CRAN (R 3.6.3) ## zCompositions 1.3.4 2020-03-04 [1] CRAN (R 3.6.3) ## zlibbioc 1.32.0 2019-10-29 [2] Bioconductor ## ## [1] /share/home/tongbangzhuo/R/x86_64-pc-linux-gnu-library/3.6 ## [2] /opt/R-3.6.3/lib/R/library ## ## R ── Package was removed from disk. ## ## ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── References "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
